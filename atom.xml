<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title> John&#39;s Blog</title>
  <subtitle>张晓明的博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2016-07-14T07:30:56.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>John</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>通俗理解卷积神经网络(CNN)[转载]</title>
    <link href="http://yoursite.com/2016/07/11/%E9%80%9A%E4%BF%97%E7%90%86%E8%A7%A3%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C(CNN)/"/>
    <id>http://yoursite.com/2016/07/11/通俗理解卷积神经网络(CNN)/</id>
    <published>2016-07-10T16:00:00.000Z</published>
    <updated>2016-07-14T07:30:56.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;1-人工神经网络&quot;&gt;&lt;a href=&quot;#1-人工神经网络&quot; class=&quot;headerlink&quot; title=&quot;1.人工神经网络&quot;&gt;&lt;/a&gt;1.人工神经网络&lt;/h2&gt;&lt;h3 id=&quot;1-1神经元&quot;&gt;&lt;a href=&quot;#1-1神经元&quot; class=&quot;headerlink&quot; title=&quot;1.1神经元&quot;&gt;&lt;/a&gt;1.1神经元&lt;/h3&gt;&lt;p&gt;神经网络由大量的神经元相互连接而成。每个神经元接受线性组合的输入后，最开始只是简单的线性加权，后来给每个神经元加上了非线性的激活函数，从而进行非线性变换后输出。每两个神经元之间的连接代表加权值，称之为权重（weight）。不同的权重和激活函数，则会导致神经网络不同的输出。&lt;/p&gt;
&lt;p&gt;举个手写识别的例子，给定一个未知数字，让神经网络识别是什么数字。此时的神经网络的输入由一组被输入图像的像素所激活的输入神经元所定义。在通过非线性激活函数进行非线性变换后，神经元被激活然后被传递到其他神经元。重复这一过程，直到最后一个输出神经元被激活。从而识别当前数字是什么字。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;br&gt;    神经网络的每个神经元如下&lt;br&gt;    &lt;img src=&quot;http://img.blog.csdn.net/20160703112618929&quot; alt=&quot;神经网络示例&quot;&gt;&lt;br&gt;类似wx + b的形式，其中&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;a1~an为输入向量，当然，也常用x1~xn表示输入&lt;/li&gt;
&lt;li&gt;w1~wn为权重&lt;/li&gt;
&lt;li&gt;b为偏置bias&lt;/li&gt;
&lt;li&gt;f 为激活函数&lt;/li&gt;
&lt;li&gt;&lt;p&gt;t 为输出&lt;br&gt;  如果只是上面这样一说，估计以前没接触过的十有八九又必定迷糊了。事实上，上述简单模型可以追溯到20世纪50/60年代的感知器，可以把感知器理解为一个根据不同因素、以及各个因素的重要性程度而做决策的模型。&lt;/p&gt;
&lt;p&gt;  举个例子，这周末北京有一草莓音乐节，那去不去呢？决定你是否去有3个因素，这三个因素可以对应三个输入，分别用x1、x2、x3表示。此外，这三个因素对做决策的影响程度不一样，各自的影响程度用权重w1、w2、w3表示。一般来说，音乐节的演唱嘉宾会非常影响你去不去，唱得好的前提下 即便天气不好、没人陪同都可忍受，但如果唱得不好还不如你上台唱呢。所以，我们可以如下表示：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;x1：是否有喜欢的演唱嘉宾。x1 = 1 你喜欢这些嘉宾，x1 = 0 你不喜欢这些嘉宾。嘉宾因素的权重w1 = 5&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;x2：天气好坏。x2 = 1 天气好，x2 = 0 天气不好。天气权重w2 = 2。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;x3：是否有人陪你同去。x3 = 1 有人陪你同去，x2 = 0 没人陪你同去。是否有陪同的权重w3 = 3。&lt;br&gt;  这样，咱们的决策模型函数便建立起来了：f(x) = g( w1&lt;em&gt;x1 + w2&lt;/em&gt;x2 + w3*x3 + b )，g表示激活函数。然后设定一个阈值，如果这些加权输入值的和[ 即f(x) ]超过这个阈值，就输出1：代表去参加音乐节，否则输出0：代表不去参加音乐节。&lt;br&gt;  一开始，激活函数是线性函数，导致所有的变换都是线性变换，比如if x &amp;lt; 0 f(x) = 0; if x &amp;gt; 0,f(x) = 1，输出都是输入的线性变换。后来实际应用中发现，线性激活函数太过局限，于是人们引入了非线性激活函数。&lt;/p&gt;
&lt;h3 id=&quot;1-2神经网络&quot;&gt;&lt;a href=&quot;#1-2神经网络&quot; class=&quot;headerlink&quot; title=&quot;1.2神经网络&quot;&gt;&lt;/a&gt;1.2神经网络&lt;/h3&gt;&lt;p&gt;将下图的这种单个神经元&lt;br&gt;&lt;img src=&quot;http://img.blog.csdn.net/20160703140734967&quot; alt=&quot;神经网络示例&quot;&gt;&lt;br&gt;组织在一起，便形成了神经网络。下图便是一个三层神经网络结构&lt;br&gt;&lt;img src=&quot;http://img.blog.csdn.net/20160703140745657&quot; alt=&quot;神经网络示例&quot;&gt;&lt;br&gt;上图中最左边的原始输入信息称之为输入层，最右边的神经元称之为输出层（上图中输出层只有一个神经元），中间的叫隐藏层。&lt;/p&gt;
&lt;p&gt;  啥叫输入层、输出层、隐藏层呢？&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;输入层（Input layer），众多神经元（Neuron）接受大量非线形输入讯息。输入的讯息称为输入向量。&lt;br&gt;输出层（Output layer），讯息在神经元链接中传输、分析、权衡，形成输出结果。输出的讯息称为输出向量。&lt;br&gt;隐藏层（Hidden layer），简称“隐层”，是输入层和输出层之间众多神经元和链接组成的各个层面。如果有多个隐藏层，则意味着多个激活函数。&lt;br&gt;    同时，每一层都可能由单个或多个神经元组成，每一层的输出将会作为下一层的输入数据。比如下图中间隐藏层来说，隐藏层的3个神经元a1、a2、a3皆各自接受来自多个不同权重的输入，接着，a1、a2、a3又在自身各自不同权重的影响下 成为的输出层的输入，最终由输出层输出最终结果。&lt;br&gt; &lt;img src=&quot;http://img.blog.csdn.net/20160703110336151&quot; alt=&quot;神经网络示例&quot;&gt;&lt;br&gt;  &lt;img src=&quot;http://img.blog.csdn.net/20160703113851013&quot; alt=&quot;神经网络示例&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;2-CNN之卷积计算层&quot;&gt;&lt;a href=&quot;#2-CNN之卷积计算层&quot; class=&quot;headerlink&quot; title=&quot;2.CNN之卷积计算层&quot;&gt;&lt;/a&gt;2.CNN之卷积计算层&lt;/h2&gt;&lt;h3 id=&quot;2-1什么是卷积&quot;&gt;&lt;a href=&quot;#2-1什么是卷积&quot; class=&quot;headerlink&quot; title=&quot;2.1什么是卷积&quot;&gt;&lt;/a&gt;2.1什么是卷积&lt;/h3&gt;&lt;p&gt; 首先，我们来了解下什么是卷积操作。&lt;br&gt;    对图像（不同的数据窗口数据）和滤波矩阵（一组固定的权重：因为每个神经元的权重固定，所以又可以看做一个恒定的滤波器filter）做内积（逐个元素相乘再求和）的操作就是所谓的『卷积』操作，也是卷积神经网络的名字来源。&lt;br&gt;    比如下图中，图中左边部分是原始输入数据，图中中间部分是滤波器filter，图中右边是输出的新的二维数据。&lt;br&gt; &lt;img src=&quot;http://img.blog.csdn.net/20160702215705128&quot; alt=&quot;神经网络示例&quot;&gt;&lt;br&gt;中间滤波器filter与数据窗口做内积，其具体计算过程则是：4&lt;em&gt;0 + 0&lt;/em&gt;0 + 0&lt;em&gt;0 + 0&lt;/em&gt;0 + 0&lt;em&gt;1 + 0&lt;/em&gt;1 + 0&lt;em&gt;0 + 0&lt;/em&gt;1 + -4*2 = -8&lt;/p&gt;
&lt;h3 id=&quot;2-2动态卷积图&quot;&gt;&lt;a href=&quot;#2-2动态卷积图&quot; class=&quot;headerlink&quot; title=&quot;2.2动态卷积图&quot;&gt;&lt;/a&gt;2.2动态卷积图&lt;/h3&gt;&lt;p&gt;在CNN中，滤波器filter对局部输入数据进行卷积计算。每计算完一个数据窗口内的局部数据后，数据窗口不断平移滑动，直到计算完所有数据。这个过程中，有这么几个参数：&lt;br&gt;　　a. 深度depth：神经元个数，决定输出的depth厚度。&lt;br&gt;　　b. 步长stride：决定滑动多少步可以到边缘&lt;br&gt;　　c. 填充值zero-padding：在外围边缘补充若干圈0，方便从初始位置以步长为单位可以刚好滑倒末尾位置，通俗地讲就是为了总长能被步长整除。&lt;br&gt;&lt;img src=&quot;http://img.blog.csdn.net/20160707204048899&quot; alt=&quot;神经网络示例&quot;&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-人工神经网络&quot;&gt;&lt;a href=&quot;#1-人工神经网络&quot; class=&quot;headerlink&quot; title=&quot;1.人工神经网络&quot;&gt;&lt;/a&gt;1.人工神经网络&lt;/h2&gt;&lt;h3 id=&quot;1-1神经元&quot;&gt;&lt;a href=&quot;#1-1神经元&quot; class=&quot;headerlink&quot; title=&quot;1.1神经元&quot;&gt;&lt;/a&gt;1.1神经元&lt;/h3&gt;&lt;p&gt;神经网络由大量的神经元相互连接而成。每个神经元接受线性组合的输入后，最开始只是简单的线性加权，后来给每个神经元加上了非线性的激活函数，从而进行非线性变换后输出。每两个神经元之间的连接代表加权值，称之为权重（weight）。不同的权重和激活函数，则会导致神经网络不同的输出。&lt;/p&gt;
&lt;p&gt;举个手写识别的例子，给定一个未知数字，让神经网络识别是什么数字。此时的神经网络的输入由一组被输入图像的像素所激活的输入神经元所定义。在通过非线性激活函数进行非线性变换后，神经元被激活然后被传递到其他神经元。重复这一过程，直到最后一个输出神经元被激活。从而识别当前数字是什么字。&lt;br&gt;
    
    </summary>
    
      <category term="Deep Learning" scheme="http://yoursite.com/categories/Deep-Learning/"/>
    
    
      <category term="Deep Learning" scheme="http://yoursite.com/tags/Deep-Learning/"/>
    
  </entry>
  
  <entry>
    <title>C/C++中计算程序运行时间的方法</title>
    <link href="http://yoursite.com/2016/07/09/C:C++%E4%B8%AD%E8%AE%A1%E7%AE%97%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E6%97%B6%E9%97%B4%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2016/07/09/C:C++中计算程序运行时间的方法/</id>
    <published>2016-07-08T16:00:00.000Z</published>
    <updated>2016-07-14T07:07:00.000Z</updated>
    
    <content type="html">&lt;p&gt;最近写完程序在公司需要测试每个句子输入到返回结果的运行时间，刚开始使用clock()函数是精确到毫秒，但是经过测试然并卵，总是返回0ms，程序运行时间太短，最后总结一下：&lt;/p&gt;
&lt;h3 id=&quot;精确到毫秒ms&quot;&gt;&lt;a href=&quot;#精确到毫秒ms&quot; class=&quot;headerlink&quot; title=&quot;精确到毫秒ms&quot;&gt;&lt;/a&gt;精确到毫秒ms&lt;/h3&gt;&lt;p&gt;clock()计算的是CPU执行耗时，注意是CPU！如果有多个核并行，最后的结果是每个CPU上运算时间的总和！想要精确到毫秒，可以double(end -begin)*1000/CLOCKS_PER_SEC&lt;br&gt;一般来说，只要求精确到秒的话，time是很好使的&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;#include &amp;lt;&amp;lt;/span&amp;gt;stdio.h&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;#include &amp;lt;&amp;lt;/span&amp;gt;time.h&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;int main()&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    time_t t_start, t_end;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    t_start = time(NULL) ;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    sleep(3000);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    t_end = time(NULL) ;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    printf(&amp;quot;time: %.0f s\n&amp;quot;, difftime(t_end,t_start)) ;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    return 0;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;精确到微秒us&quot;&gt;&lt;a href=&quot;#精确到微秒us&quot; class=&quot;headerlink&quot; title=&quot;精确到微秒us&quot;&gt;&lt;/a&gt;精确到微秒us&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;#include &amp;lt;&amp;lt;/span&amp;gt;stdio.h&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;#include &amp;lt;&amp;lt;/span&amp;gt;sys/time.h&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;int main() &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    struct timeval start, end;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    gettimeofday( &amp;amp;start, NULL );&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    sleep(3);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    gettimeofday( &amp;amp;end, NULL );&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    int timeuse = 1000000 * ( end.tv_sec - start.tv_sec ) + end.tv_usec -start.tv_usec;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    printf(&amp;quot;time: %d us\n&amp;quot;, timeuse);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    return 0;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;最近写完程序在公司需要测试每个句子输入到返回结果的运行时间，刚开始使用clock()函数是精确到毫秒，但是经过测试然并卵，总是返回0ms，程序运行时间太短，最后总结一下：&lt;/p&gt;
&lt;h3 id=&quot;精确到毫秒ms&quot;&gt;&lt;a href=&quot;#精确到毫秒ms&quot; class=&quot;headerlink&quot; title=&quot;精确到毫秒ms&quot;&gt;&lt;/a&gt;精确到毫秒ms&lt;/h3&gt;&lt;p&gt;clock()计算的是CPU执行耗时，注意是CPU！如果有多个核并行，最后的结果是每个CPU上运算时间的总和！想要精确到毫秒，可以double(end -begin)*1000/CLOCKS_PER_SEC&lt;br&gt;一般来说，只要求精确到秒的话，time是很好使的&lt;br&gt;
    
    </summary>
    
      <category term="C/C++" scheme="http://yoursite.com/categories/C-C/"/>
    
    
      <category term="-C/C++ -运行时间" scheme="http://yoursite.com/tags/C-C-%E8%BF%90%E8%A1%8C%E6%97%B6%E9%97%B4/"/>
    
  </entry>
  
  <entry>
    <title>利用标注语料生成决策weights</title>
    <link href="http://yoursite.com/2016/07/05/%E5%88%A9%E7%94%A8%E6%A0%87%E6%B3%A8%E8%AF%AD%E6%96%99%E7%94%9F%E6%88%90%E5%86%B3%E7%AD%96weights/"/>
    <id>http://yoursite.com/2016/07/05/利用标注语料生成决策weights/</id>
    <published>2016-07-04T16:00:00.000Z</published>
    <updated>2016-07-08T09:18:09.000Z</updated>
    
    <content type="html">&lt;p&gt;1、之前两周利用主动学习的方式训练集&lt;br&gt;2、标注数据分离一小部分作为测试集利用LR分类器调参。&lt;br&gt;3、利用最有参数训练标注语料生成特征权重weights。&lt;br&gt;3、使用weights获得主干提取demo。&lt;br&gt;周一的时候做好了主干提取的Demo初始版本，经过测试效果不太理想&lt;br&gt;分析原因：训练集过少、覆盖面过窄、稳定性不高&lt;br&gt;这周的主要工作：&lt;br&gt;1、提取多种语料库中的资源做人工语料标注&lt;br&gt;2、增加部分特征，扩大特征维度&lt;br&gt;3、特征结构统一化，例如某个词的特征用词典表示，预定义好所有的key。暂时定义如下：&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;列表内容&lt;/li&gt;
&lt;li&gt;word_0  当前词本身&lt;/li&gt;
&lt;li&gt;pos_0  当前词本身词性&lt;/li&gt;
&lt;li&gt;cluster_0 当前词本身聚类编号&lt;/li&gt;
&lt;li&gt;word_-1  当前词的前一个词本身&lt;/li&gt;
&lt;li&gt;pos_-1   当前词的前一个词词性&lt;/li&gt;
&lt;li&gt;cluster_-1   当前词的前一个词聚类编号&lt;/li&gt;
&lt;li&gt;word_1   当前词的后一个词本身&lt;/li&gt;
&lt;li&gt;pos_1    当前词的后一个词词性&lt;/li&gt;
&lt;li&gt;cluster_1   当前词的后一个词聚类编号&lt;/li&gt;
&lt;li&gt;parent_edge_0   当前词的父边关系类型&lt;/li&gt;
&lt;li&gt;child_edge_0   当前词的子边关系类型&lt;/li&gt;
&lt;li&gt;word_parent_node_0   当前词的父节点词本身&lt;/li&gt;
&lt;li&gt;pos_parent_node_0  当前词的父节点词性&lt;/li&gt;
&lt;li&gt;cluster_parent_node_0 当前词的父节点词聚类编号&lt;/li&gt;
&lt;li&gt;word_parent&lt;em&gt;node&lt;/em&gt;-1   当前词的前一个词的父节点词本身&lt;/li&gt;
&lt;li&gt;pos_parent&lt;em&gt;node&lt;/em&gt;-1  当前词的前一个词的父节点词性&lt;/li&gt;
&lt;li&gt;cluster_parent&lt;em&gt;node&lt;/em&gt;-1 当前词的前一个词的父节点词聚类编号&lt;/li&gt;
&lt;li&gt;word_parent_node_1   当前词的后一个词的父节点词本身&lt;/li&gt;
&lt;li&gt;pos_parent_node_1  当前词的后一个词的父节点词性&lt;/li&gt;
&lt;li&gt;cluster_parent_node_1 当前词的后一个词的父节点词聚类编号&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;计划下周：&lt;br&gt;把句子主干提取完善版本完成。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;1、之前两周利用主动学习的方式训练集&lt;br&gt;2、标注数据分离一小部分作为测试集利用LR分类器调参。&lt;br&gt;3、利用最有参数训练标注语料生成特征权重weights。&lt;br&gt;3、使用weights获得主干提取demo。&lt;br&gt;周一的时候做好了主干提取的Demo初始版本，经过测试效果不太理想&lt;br&gt;分析原因：训练集过少、覆盖面过窄、稳定性不高&lt;br&gt;这周的主要工作：&lt;br&gt;1、提取多种语料库中的资源做人工语料标注&lt;br&gt;2、增加部分特征，扩大特征维度&lt;br&gt;3、特征结构统一化，例如某个词的特征用词典表示，预定义好所有的key。暂时定义如下：&lt;/p&gt;
    
    </summary>
    
      <category term="句子主干提取" scheme="http://yoursite.com/categories/%E5%8F%A5%E5%AD%90%E4%B8%BB%E5%B9%B2%E6%8F%90%E5%8F%96/"/>
    
    
      <category term="逻辑回归" scheme="http://yoursite.com/tags/%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/"/>
    
      <category term="主动学习" scheme="http://yoursite.com/tags/%E4%B8%BB%E5%8A%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>通过主动学习的方法进行自动语料标注</title>
    <link href="http://yoursite.com/2016/06/24/%E9%80%9A%E8%BF%87%E4%B8%BB%E5%8A%A8%E5%AD%A6%E4%B9%A0%E7%9A%84%E6%96%B9%E6%B3%95%E8%BF%9B%E8%A1%8C%E8%87%AA%E5%8A%A8%E8%AF%AD%E6%96%99%E6%A0%87%E6%B3%A8/"/>
    <id>http://yoursite.com/2016/06/24/通过主动学习的方法进行自动语料标注/</id>
    <published>2016-06-23T16:00:00.000Z</published>
    <updated>2016-07-08T10:50:19.000Z</updated>
    
    <content type="html">&lt;p&gt;   目前正在做句子主干提取方面的工作，主要方法是构建二分类器，提取句子分词之后每个词的特征来决定分词的取舍。由于需要标注大量的训练语料，采用人工的方法费时费力，于是采用主动学习的方法实现语料标注，我实现的步骤如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;先对语料实现人工标注一部分&lt;/li&gt;
&lt;li&gt;使用机器学习训练模型如SVM、LR对已经标注的语料训练，把为标注的语料作为测试集&lt;/li&gt;
&lt;li&gt;为测试机样本产生标签及置信度（即标签的准确性的概率值）&lt;/li&gt;
&lt;li&gt;通过观察为置信度设定一个阈值，当样本中的每个分词都满足这个阈值时，我们把这个自动标注好的测试样本加入到训练集中，在测试样本中取出这个样本&lt;/li&gt;
&lt;li&gt;重复2-4步，直到剩余的测试样本中没有完全满足阈值的&lt;/li&gt;
&lt;li&gt;&lt;p&gt;输出剩余的测试样本&lt;/p&gt;
&lt;p&gt; 刚开始我觉得这种方法非常好，经过测试，大概20次迭代之后大概4/5的样本已经标注好了&lt;br&gt;经过导师指导发现这种方法并不可靠，因为你新添加的训练集也是之前训练集产生的，反复迭代只会过拟合。我们应该设定一个比较低的阈值，找到测试集中非常不确定的测试样本（所有这些测试样本的置信度很低），通常来说这些样本是最有“价值”的样本，我们对这一小部分采用人工标注，并放入到训练集中，反复几次。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;   目前正在做句子主干提取方面的工作，主要方法是构建二分类器，提取句子分词之后每个词的特征来决定分词的取舍。由于需要标注大量的训练语料，采用人工的方法费时费力，于是采用主动学习的方法实现语料标注，我实现的步骤如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;先对语料实现人工标注一部分&lt;/
    
    </summary>
    
      <category term="句子主干提取" scheme="http://yoursite.com/categories/%E5%8F%A5%E5%AD%90%E4%B8%BB%E5%B9%B2%E6%8F%90%E5%8F%96/"/>
    
    
      <category term="逻辑回归" scheme="http://yoursite.com/tags/%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/"/>
    
      <category term="主动学习" scheme="http://yoursite.com/tags/%E4%B8%BB%E5%8A%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Pagerank算法的具体实现</title>
    <link href="http://yoursite.com/2016/06/19/pagerank%E7%AE%97%E6%B3%95%E7%9A%84%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0/"/>
    <id>http://yoursite.com/2016/06/19/pagerank算法的具体实现/</id>
    <published>2016-06-18T16:00:00.000Z</published>
    <updated>2016-07-08T07:02:10.000Z</updated>
    
    <content type="html">&lt;p&gt;PageRank对网页排名的算法，曾是Google发家致富的法宝。以前虽然有实验过，但理解还是不透彻，这几天又看了一下，这里总结一下PageRank算法的基本原理。&lt;/p&gt;
&lt;h3 id=&quot;1、什么是pagerank&quot;&gt;&lt;a href=&quot;#1、什么是pagerank&quot; class=&quot;headerlink&quot; title=&quot;1、什么是pagerank&quot;&gt;&lt;/a&gt;1、什么是pagerank&lt;/h3&gt;&lt;p&gt;PageRank的Page可是认为是网页，表示网页排名，也可以认为是Larry Page(google 产品经理)，因为他是这个算法的发明者之一，还是google CEO（^_^）。PageRank算法计算每一个网页的PageRank值，然后根据这个值的大小对网页的重要性进行排序。它的思想是模拟一个悠闲的上网者，上网者首先随机选择一个网页打开，然后在这个网页上呆了几分钟后，跳转到该网页所指向的链接，这样无所事事、漫无目的地在网页上跳来跳去，PageRank就是估计这个悠闲的上网者分布在各个网页上的概率。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;2、最简单pagerank模型&quot;&gt;&lt;a href=&quot;#2、最简单pagerank模型&quot; class=&quot;headerlink&quot; title=&quot;2、最简单pagerank模型&quot;&gt;&lt;/a&gt;2、最简单pagerank模型&lt;/h3&gt;&lt;p&gt;互联网中的网页可以看出是一个有向图，其中网页是结点，如果网页A有链接到网页B，则存在一条有向边A-&amp;gt;B，下面是一个简单的示例：&lt;br&gt;&lt;img src=&quot;http://jbcdn2.b0.upaiyun.com/2014/06/ca4f4c96cd2294c797ddf585c4188074.jpg&quot; alt=&quot;pagerank示例&quot;&gt;&lt;br&gt;这个例子中只有四个网页，如果当前在A网页，那么悠闲的上网者将会各以1/3的概率跳转到B、C、D，这里的3表示A有3条出链，如果一个网页有k条出链，那么跳转任意一个出链上的概率是1/k，同理D到B、C的概率各为1/2，而B到C的概率为0。一般用转移矩阵表示上网者的跳转概率，如果用n表示网页的数目，则转移矩阵M是一个n*n的方阵；如果网页j有k个出链，那么对每一个出链指向的网页i，有M[i][j]=1/k，而其他网页的M[i][j]=0；上面示例图对应的转移矩阵如下：&lt;br&gt;&lt;img src=&quot;http://jbcdn2.b0.upaiyun.com/2014/06/4162fcd6ae797038923715cca812e3b9.jpg&quot; alt=&quot;pagerank示例&quot;&gt;&lt;br&gt;初试时，假设上网者在每一个网页的概率都是相等的，即1/n，于是初试的概率分布就是一个所有值都为1/n的n维列向量V0，用V0去右乘转移矩阵M，就得到了第一步之后上网者的概率分布向量MV0,（nXn）*(nX1)依然得到一个nX1的矩阵。下面是V1的计算过程：&lt;br&gt;&lt;img src=&quot;http://jbcdn2.b0.upaiyun.com/2014/06/4be2f7275f8b1880bbf99e08240fec7f.jpg&quot; alt=&quot;pagerank示例&quot;&gt;&lt;br&gt;注意矩阵M中M[i][j]不为0表示用一个链接从j指向i，M的第一行乘以V0，表示累加所有网页到网页A的概率即得到9/24。得到了V1后，再用V1去右乘M得到V2，一直下去，最终V会收敛，即Vn=MV(n-1)，上面的图示例，不断的迭代，最终V=[3/9,2/9,2/9,2/9]’：&lt;br&gt;&lt;img src=&quot;http://jbcdn2.b0.upaiyun.com/2014/06/2e906d4e9404a5aadf2938f001ad0ea7.jpg&quot; alt=&quot;pagerank示例&quot;&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;PageRank对网页排名的算法，曾是Google发家致富的法宝。以前虽然有实验过，但理解还是不透彻，这几天又看了一下，这里总结一下PageRank算法的基本原理。&lt;/p&gt;
&lt;h3 id=&quot;1、什么是pagerank&quot;&gt;&lt;a href=&quot;#1、什么是pagerank&quot; class=&quot;headerlink&quot; title=&quot;1、什么是pagerank&quot;&gt;&lt;/a&gt;1、什么是pagerank&lt;/h3&gt;&lt;p&gt;PageRank的Page可是认为是网页，表示网页排名，也可以认为是Larry Page(google 产品经理)，因为他是这个算法的发明者之一，还是google CEO（^_^）。PageRank算法计算每一个网页的PageRank值，然后根据这个值的大小对网页的重要性进行排序。它的思想是模拟一个悠闲的上网者，上网者首先随机选择一个网页打开，然后在这个网页上呆了几分钟后，跳转到该网页所指向的链接，这样无所事事、漫无目的地在网页上跳来跳去，PageRank就是估计这个悠闲的上网者分布在各个网页上的概率。&lt;br&gt;
    
    </summary>
    
      <category term="实体链接" scheme="http://yoursite.com/categories/%E5%AE%9E%E4%BD%93%E9%93%BE%E6%8E%A5/"/>
    
    
      <category term="PageRank" scheme="http://yoursite.com/tags/PageRank/"/>
    
      <category term="Graph Model" scheme="http://yoursite.com/tags/Graph-Model/"/>
    
  </entry>
  
  <entry>
    <title>单链表反转问题</title>
    <link href="http://yoursite.com/2016/06/15/%E5%8D%95%E9%93%BE%E8%A1%A8%E5%8F%8D%E8%BD%AC%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2016/06/15/单链表反转问题/</id>
    <published>2016-06-14T16:00:00.000Z</published>
    <updated>2016-07-08T06:55:23.000Z</updated>
    
    <content type="html">&lt;p&gt;题目：定义一个函数，输入一个链表的头结点，反转该链表并输出反转后链表的头结点。&lt;/p&gt;
&lt;h3 id=&quot;1、非递归方式实现&quot;&gt;&lt;a href=&quot;#1、非递归方式实现&quot; class=&quot;headerlink&quot; title=&quot;1、非递归方式实现&quot;&gt;&lt;/a&gt;1、非递归方式实现&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;//思路为将节点从前到后依次放到表头，最后最后的节点到了最前面,最前面的节点到了最后面  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;ListNode * ReverseList(ListNode *  head)  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#123;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   //如果链表为空或者链表中只有一个元素  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   if(head==NULL || head-&amp;gt;m_pNext==NULL)  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;       return head;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   ListNode * p=head-&amp;gt;m_pNext;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   ListNode * q=head;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   while(p!=NULL)  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   &amp;#123;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;     q-&amp;gt;m_pNext=p-&amp;gt;m_pNext;//记录下p的下一个节点  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;     p-&amp;gt;m_pNext=head;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;     head=p;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;     p=q-&amp;gt;m_pNext;//准备将p的下一个节点放到表头  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   &amp;#125;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   return head;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;2、递归方式实现&quot;&gt;&lt;a href=&quot;#2、递归方式实现&quot; class=&quot;headerlink&quot; title=&quot;2、递归方式实现&quot;&gt;&lt;/a&gt;2、递归方式实现&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;ListNode * ReverseList2(ListNode * head)  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#123;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    //如果链表为空或者链表中只有一个元素  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    if(head==NULL || head-&amp;gt;m_pNext==NULL)  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        return head;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    else  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#123;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;       ListNode * newhead=ReverseList2(head-&amp;gt;m_pNext);//先反转后面的链表  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;       head-&amp;gt;m_pNext-&amp;gt;m_pNext=head;//再将当前节点设置为其然来后面节点的后续节点  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;       head-&amp;gt;m_pNext=NULL;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;       return newhead;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;3、完整的代码流程&quot;&gt;&lt;a href=&quot;#3、完整的代码流程&quot; class=&quot;headerlink&quot; title=&quot;3、完整的代码流程&quot;&gt;&lt;/a&gt;3、完整的代码流程&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;23&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;24&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;25&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;26&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;27&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;28&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;29&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;30&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;31&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;32&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;33&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;34&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;35&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;36&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;37&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;38&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;39&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;40&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;41&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;42&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;43&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;44&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;45&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;46&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;47&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;48&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;49&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;50&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;51&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;52&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;53&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;54&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;55&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;56&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;57&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;58&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;59&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;60&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;61&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;62&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;63&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;64&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;65&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;66&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;67&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;68&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;69&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;70&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;71&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;72&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;73&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;74&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;75&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;76&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;77&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;78&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;79&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;80&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;81&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;82&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;83&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;84&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;// 反转链表.cpp : 定义控制台应用程序的入口点。  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;#include &amp;quot;stdafx.h&amp;quot;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;#include  &amp;lt;iostream&amp;gt;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;using namespace std;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;//定义一个链表节点  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt; typedef struct ListNode  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#123;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    int       m_nKey;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    struct ListNode * m_pNext;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;ListNode;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;//插入一个新节点到链表中(放在链表头部)  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;void CreateList(ListNode * &amp;amp; head,int data)  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#123;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    //创建新节点  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    ListNode * p=(ListNode*)malloc(sizeof(ListNode));  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    p-&amp;gt;m_nKey=data;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    p-&amp;gt;m_pNext=NULL;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    if(head==NULL)  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#123;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        head=p;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        return;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    p-&amp;gt;m_pNext=head;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    head=p;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;void  printList(ListNode* head)  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#123;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   ListNode * p=head;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   while(p!=NULL)  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   &amp;#123;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      cout&amp;lt;&amp;lt;p-&amp;gt;m_nKey&amp;lt;&amp;lt;&amp;quot; &amp;quot;;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      p=p-&amp;gt;m_pNext;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   &amp;#125;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   cout&amp;lt;&amp;lt;endl;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;//思路为将节点从前到后依次放到表头，最后最后的节点到了最前面,最前面的节点到了最后面  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;ListNode * ReverseList(ListNode *  head)  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#123;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   //如果链表为空或者链表中只有一个元素  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   if(head==NULL || head-&amp;gt;m_pNext==NULL)  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;       return head;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   ListNode * p=head-&amp;gt;m_pNext;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   ListNode * q=head;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   while(p!=NULL)  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   &amp;#123;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;     q-&amp;gt;m_pNext=p-&amp;gt;m_pNext;//记录下p的下一个节点  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;     p-&amp;gt;m_pNext=head;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;     head=p;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;     p=q-&amp;gt;m_pNext;//准备将p的下一个节点放到表头  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   &amp;#125;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   return head;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;//递归方式  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;ListNode * ReverseList2(ListNode * head)  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#123;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    //如果链表为空或者链表中只有一个元素  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    if(head==NULL || head-&amp;gt;m_pNext==NULL)  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        return head;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    else  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#123;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;       ListNode * newhead=ReverseList2(head-&amp;gt;m_pNext);//先反转后面的链表  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;       head-&amp;gt;m_pNext-&amp;gt;m_pNext=head;//再将当前节点设置为其然来后面节点的后续节点  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;       head-&amp;gt;m_pNext=NULL;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;       return newhead;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;int _tmain(int argc, _TCHAR* argv[])  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#123;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    ListNode * Head=NULL;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    for(int i=0;i&amp;lt;10;i++)  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      CreateList(Head,i);  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    printList(Head);  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    Head=ReverseList(Head);  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    printList(Head);  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    system(&amp;quot;PAUSE&amp;quot;);  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    return 0;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;题目：定义一个函数，输入一个链表的头结点，反转该链表并输出反转后链表的头结点。&lt;/p&gt;
&lt;h3 id=&quot;1、非递归方式实现&quot;&gt;&lt;a href=&quot;#1、非递归方式实现&quot; class=&quot;headerlink&quot; title=&quot;1、非递归方式实现&quot;&gt;&lt;/a&gt;1、非递归方式实现&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;//思路为将节点从前到后依次放到表头，最后最后的节点到了最前面,最前面的节点到了最后面  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;ListNode * ReverseList(ListNode *  head)  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#123;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   //如果链表为空或者链表中只有一个元素  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   if(head==NULL || head-&amp;gt;m_pNext==NULL)  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;       return head;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   ListNode * p=head-&amp;gt;m_pNext;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   ListNode * q=head;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   while(p!=NULL)  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   &amp;#123;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;     q-&amp;gt;m_pNext=p-&amp;gt;m_pNext;//记录下p的下一个节点  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;     p-&amp;gt;m_pNext=head;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;     head=p;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;     p=q-&amp;gt;m_pNext;//准备将p的下一个节点放到表头  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   &amp;#125;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   return head;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
