<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title> John&#39;s Blog</title>
  <subtitle>张晓明的博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2016-08-08T03:39:43.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>John</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>利用linux命令sort和uniq求两个文件的交集并集和补集</title>
    <link href="http://yoursite.com/2016/08/05/%E5%88%A9%E7%94%A8linux%E5%91%BD%E4%BB%A4sort%E5%92%8Cuniq%E6%B1%82%E4%B8%A4%E4%B8%AA%E6%96%87%E4%BB%B6%E7%9A%84%E4%BA%A4%E9%9B%86%E5%B9%B6%E9%9B%86%E5%92%8C%E8%A1%A5%E9%9B%86/"/>
    <id>http://yoursite.com/2016/08/05/利用linux命令sort和uniq求两个文件的交集并集和补集/</id>
    <published>2016-08-04T16:00:00.000Z</published>
    <updated>2016-08-08T03:39:43.000Z</updated>
    
    <content type="html">&lt;p&gt;给定两个文件 a.txt 和 b.txt ，每行是一个记录（假设没有重复），要求输出两集合的交集、并集、差集，输出的结果只包括唯一项。交集定义为同时出现在两个文件中的记录项，并集定义为出现在任何一个文件中的记录项，差集(A-B)定义为出现在A中而且不出现在B中的记录，对称差集定义为只出现在一个文件中的记录。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;S&lt;br&gt;假设 a.txt 包括 a, c, b 三行。假设 b.txt 包括 d, e, c, b 四行。&lt;/p&gt;
&lt;p&gt;交集，把两个文件放到一起排序，只输出次数多于一次的项：&lt;br&gt;$ sort a.txt b.txt | uniq -d&lt;br&gt;b&lt;br&gt;c&lt;/p&gt;
&lt;p&gt;并集，把两个文件放到一起排序，重复的项只算一次：&lt;br&gt;$ sort a.txt b.txt | uniq&lt;br&gt;a&lt;br&gt;b&lt;br&gt;c&lt;br&gt;d&lt;br&gt;e&lt;/p&gt;
&lt;p&gt;差集(A-B)，把B的元素重复2份和A的元素放到一起排序，只输出出现一次的项：&lt;br&gt;$ sort a.txt b.txt b.txt | uniq -u&lt;br&gt;a&lt;/p&gt;
&lt;p&gt;对称差，把两个文件放到一起排序，只输出出现一次的项：&lt;br&gt;$ sort a.txt b.txt | uniq -u&lt;br&gt;a&lt;br&gt;d&lt;br&gt;e&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;给定两个文件 a.txt 和 b.txt ，每行是一个记录（假设没有重复），要求输出两集合的交集、并集、差集，输出的结果只包括唯一项。交集定义为同时出现在两个文件中的记录项，并集定义为出现在任何一个文件中的记录项，差集(A-B)定义为出现在A中而且不出现在B中的记录，对称差集定义为只出现在一个文件中的记录。&lt;br&gt;
    
    </summary>
    
      <category term="Linux命令" scheme="http://yoursite.com/categories/Linux%E5%91%BD%E4%BB%A4/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>linux screen命令详解</title>
    <link href="http://yoursite.com/2016/08/04/linux%20screen%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2016/08/04/linux screen命令详解/</id>
    <published>2016-08-03T16:00:00.000Z</published>
    <updated>2016-08-08T03:30:34.000Z</updated>
    
    <content type="html">&lt;h1 id=&quot;一、背景&quot;&gt;&lt;a href=&quot;#一、背景&quot; class=&quot;headerlink&quot; title=&quot;一、背景&quot;&gt;&lt;/a&gt;一、背景&lt;/h1&gt;&lt;p&gt;系统管理员经常需要SSH 或者telent 远程登录到Linux 服务器，经常运行一些需要很长时间才能完成的任务，比如系统备份、ftp 传输等等。通常情况下我们都是为每一个这样的任务开一个远程终端窗口，因为它们执行的时间太长了。必须等待它们执行完毕，在此期间不能关掉窗口或者断开连接，否则这个任务就会被杀掉，一切半途而废了。&lt;/p&gt;
&lt;h1 id=&quot;二、简介&quot;&gt;&lt;a href=&quot;#二、简介&quot; class=&quot;headerlink&quot; title=&quot;二、简介&quot;&gt;&lt;/a&gt;二、简介&lt;/h1&gt;&lt;p&gt;GNU Screen是一款由GNU计划开发的用于命令行终端切换的自由软件。用户可以通过该软件同时连接多个本地或远程的命令行会话，并在其间自由切换。&lt;/p&gt;
&lt;p&gt;GNU Screen可以看作是窗口管理器的命令行界面版本。它提供了统一的管理多个会话的界面和相应的功能。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;会话恢复&lt;br&gt;只要Screen本身没有终止，在其内部运行的会话都可以恢复。这一点对于远程登录的用户特别有用——即使网络连接中断，用户也不会失去对已经打开的命令行会话的控制。只要再次登录到主机上执行screen -r就可以恢复会话的运行。同样在暂时离开的时候，也可以执行分离命令detach，在保证里面的程序正常运行的情况下让Screen挂起（切换到后台）。这一点和图形界面下的VNC很相似。&lt;br&gt;多窗口&lt;br&gt;在Screen环境下，所有的会话都独立的运行，并拥有各自的编号、输入、输出和窗口缓存。用户可以通过快捷键在不同的窗口下切换，并可以自由的重定向各个窗口的输入和输出。Screen实现了基本的文本操作，如复制粘贴等；还提供了类似滚动条的功能，可以查看窗口状况的历史记录。窗口还可以被分区和命名，还可以监视后台窗口的活动。&lt;br&gt;会话共享&lt;br&gt;Screen可以让一个或多个用户从不同终端多次登录一个会话，并共享会话的所有特性（比如可以看到完全相同的输出）。它同时提供了窗口访问权限的机制，可以对窗口进行密码保护。&lt;br&gt;GNU’s Screen 官方站点：&lt;a href=&quot;http://www.gnu.org/software/screen/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.gnu.org/software/screen/&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;三、语法&quot;&gt;&lt;a href=&quot;#三、语法&quot; class=&quot;headerlink&quot; title=&quot;三、语法&quot;&gt;&lt;/a&gt;三、语法&lt;/h1&gt;&lt;h1 id=&quot;screen-AmRvx-ls-wipe-d-lt-作业名称-gt-h-lt-行数-gt-r-lt-作业名称-gt-s-S-lt-作业名称-gt&quot;&gt;&lt;a href=&quot;#screen-AmRvx-ls-wipe-d-lt-作业名称-gt-h-lt-行数-gt-r-lt-作业名称-gt-s-S-lt-作业名称-gt&quot; class=&quot;headerlink&quot; title=&quot;screen [-AmRvx -ls -wipe][-d &amp;lt;作业名称&amp;gt;][-h &amp;lt;行数&amp;gt;][-r &amp;lt;作业名称&amp;gt;][-s ][-S &amp;lt;作业名称&amp;gt;]&quot;&gt;&lt;/a&gt;screen [-AmRvx -ls -wipe][-d &amp;lt;作业名称&amp;gt;][-h &amp;lt;行数&amp;gt;][-r &amp;lt;作业名称&amp;gt;][-s ][-S &amp;lt;作业名称&amp;gt;]&lt;/h1&gt;&lt;p&gt;参数说明&lt;/p&gt;
&lt;p&gt;-A 　将所有的视窗都调整为目前终端机的大小。&lt;br&gt;-d &amp;lt;作业名称&amp;gt; 　将指定的screen作业离线。&lt;br&gt;-h &amp;lt;行数&amp;gt; 　指定视窗的缓冲区行数。&lt;br&gt;-m 　即使目前已在作业中的screen作业，仍强制建立新的screen作业。&lt;br&gt;-r &amp;lt;作业名称&amp;gt; 　恢复离线的screen作业。&lt;br&gt;-R 　先试图恢复离线的作业。若找不到离线的作业，即建立新的screen作业。&lt;br&gt;-s 　指定建立新视窗时，所要执行的shell。&lt;br&gt;-S &amp;lt;作业名称&amp;gt; 　指定screen作业的名称。&lt;br&gt;-v 　显示版本信息。&lt;br&gt;-x 　恢复之前离线的screen作业。&lt;br&gt;-ls或–list 　显示目前所有的screen作业。&lt;br&gt;-wipe 　检查目前所有的screen作业，并删除已经无法使用的screen作业。&lt;/p&gt;
&lt;h1 id=&quot;四、常用screen参数&quot;&gt;&lt;a href=&quot;#四、常用screen参数&quot; class=&quot;headerlink&quot; title=&quot;四、常用screen参数&quot;&gt;&lt;/a&gt;四、常用screen参数&lt;/h1&gt;&lt;p&gt;screen -S yourname -&amp;gt; 新建一个叫yourname的session&lt;br&gt;screen -ls -&amp;gt; 列出当前所有的session&lt;br&gt;screen -r yourname -&amp;gt; 回到yourname这个session&lt;br&gt;screen -d yourname -&amp;gt; 远程detach某个session&lt;br&gt;screen -d -r yourname -&amp;gt; 结束当前session并回到yourname这个session&lt;/p&gt;
&lt;p&gt;在每个screen session 下，所有命令都以 ctrl+a(C-a) 开始。&lt;br&gt;C-a ? -&amp;gt; 显示所有键绑定信息&lt;br&gt;C-a c -&amp;gt; 创建一个新的运行shell的窗口并切换到该窗口&lt;br&gt;C-a n -&amp;gt; Next，切换到下一个 window&lt;br&gt;C-a p -&amp;gt; Previous，切换到前一个 window&lt;br&gt;C-a 0..9 -&amp;gt; 切换到第 0..9 个 window&lt;br&gt;Ctrl+a [Space] -&amp;gt; 由视窗0循序切换到视窗9&lt;br&gt;C-a C-a -&amp;gt; 在两个最近使用的 window 间切换&lt;br&gt;C-a x -&amp;gt; 锁住当前的 window，需用用户密码解锁&lt;br&gt;C-a d -&amp;gt; detach，暂时离开当前session，将目前的 screen session (可能含有多个 windows) 丢到后台执行，并会回到还没进 screen 时的状态，此时在 screen session 里，每个 window 内运行的 process (无论是前台/后台)都在继续执行，即使 logout 也不影响。&lt;br&gt;C-a z -&amp;gt; 把当前session放到后台执行，用 shell 的 fg 命令则可回去。&lt;br&gt;C-a w -&amp;gt; 显示所有窗口列表&lt;br&gt;C-a t -&amp;gt; Time，显示当前时间，和系统的 load&lt;br&gt;C-a k -&amp;gt; kill window，强行关闭当前的 window&lt;br&gt;C-a [ -&amp;gt; 进入 copy mode，在 copy mode 下可以回滚、搜索、复制就像用使用 vi 一样&lt;br&gt;    C-b Backward，PageUp&lt;br&gt;    C-f Forward，PageDown&lt;br&gt;    H(大写) High，将光标移至左上角&lt;br&gt;    L Low，将光标移至左下角&lt;br&gt;    0 移到行首&lt;br&gt;    $ 行末&lt;br&gt;    w forward one word，以字为单位往前移&lt;br&gt;    b backward one word，以字为单位往后移&lt;br&gt;    Space 第一次按为标记区起点，第二次按为终点&lt;br&gt;    Esc 结束 copy mode&lt;br&gt;C-a ] -&amp;gt; Paste，把刚刚在 copy mode 选定的内容贴上&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一、背景&quot;&gt;&lt;a href=&quot;#一、背景&quot; class=&quot;headerlink&quot; title=&quot;一、背景&quot;&gt;&lt;/a&gt;一、背景&lt;/h1&gt;&lt;p&gt;系统管理员经常需要SSH 或者telent 远程登录到Linux 服务器，经常运行一些需要很长时间才能完成的任务，比如系统备份、ftp 传输等等。通常情况下我们都是为每一个这样的任务开一个远程终端窗口，因为它们执行的时间太长了。必须等待它们执行完毕，在此期间不能关掉窗口或者断开连接，否则这个任务就会被杀掉，一切半途而废了。&lt;/p&gt;
&lt;h1 id=&quot;二、简介&quot;&gt;&lt;a href=&quot;#二、简介&quot; class=&quot;headerlink&quot; title=&quot;二、简介&quot;&gt;&lt;/a&gt;二、简介&lt;/h1&gt;&lt;p&gt;GNU Screen是一款由GNU计划开发的用于命令行终端切换的自由软件。用户可以通过该软件同时连接多个本地或远程的命令行会话，并在其间自由切换。&lt;/p&gt;
&lt;p&gt;GNU Screen可以看作是窗口管理器的命令行界面版本。它提供了统一的管理多个会话的界面和相应的功能。&lt;br&gt;
    
    </summary>
    
      <category term="程序执行" scheme="http://yoursite.com/categories/%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux下vim命令详解</title>
    <link href="http://yoursite.com/2016/08/01/linux%E4%B8%8Bvim%E5%91%BD%E4%BB%A4/"/>
    <id>http://yoursite.com/2016/08/01/linux下vim命令/</id>
    <published>2016-07-31T16:00:00.000Z</published>
    <updated>2016-08-03T06:03:43.000Z</updated>
    
    <content type="html">&lt;p&gt;高级一些的编辑器，都会包含宏功能，vim当然不能缺少了，在vim中使用宏是非常方便的：&lt;/p&gt;
&lt;p&gt;:qx     开始记录宏，并将结果存入寄存器x&lt;br&gt;q     退出记录模式&lt;br&gt;@x     播放记录在x寄存器中的宏命令&lt;br&gt;稍微解释一下，当在normal模式下输入:qx后，你对文本的所有编辑动作将会被记录下来，再次输入q即退出了记录模&lt;br&gt;式，然后输入@x对刚才记录下来的命令进行重复，此命令后可跟数字，表示要重复多少次，比如@x20，可以重复20次。这个在文本的批处理中是非常有用的。&lt;br&gt;同时编辑多个文件&lt;br&gt;在vim众多的插件中，有一个叫minibuffer的插件，就是下面所说的标签页功能了，可以支持同时编辑多个文件。&lt;br&gt;标签命令&lt;/p&gt;
&lt;p&gt;:tabe fn     在一个新的标签页中编辑文件fn&lt;br&gt;gt     切换到下一个标签页&lt;br&gt;gT     切换到上一个标签页&lt;br&gt;:tabr     切换到第一个标签页&lt;br&gt;:tabl     切换到最后一个标签页&lt;br&gt;:tabm [N]     把当前tab移动到第N个tab之后&lt;br&gt;对，正如你所想象的那样，跟eclipse, ue等的标签页是一个意思！&lt;br&gt;窗口命令&lt;br&gt;ctrl+w s     水平分割窗口&lt;br&gt;ctrl+w w     切换窗口&lt;br&gt;ctrl+w q     退出当前窗口(由于同时有多个文件，此命令不会影响其他窗口)&lt;br&gt;ctrl+w v     垂直分割窗口&lt;br&gt;其他&lt;br&gt;vim在保存之前不会对文件做实际的修改，只是加载到缓冲区中，对文件的编辑其实是对缓冲区的编辑，直到:w时才会存入物理文件。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;br&gt;:e file     把file加载到新的缓冲区中&lt;br&gt;:bn     跳转到下一个缓冲区&lt;br&gt;:bd     删除缓冲区(关闭文件)&lt;br&gt;:sp fn     分割窗口，并将fn加载到新的窗口中&lt;br&gt;退出编辑器&lt;/p&gt;
&lt;p&gt;:w     将缓冲区写入文件，即保存修改&lt;br&gt;:wq     保存修改并退出&lt;br&gt;:x     保存修改并退出&lt;br&gt;:q     退出，如果对缓冲区进行过修改，则会提示&lt;br&gt;:q!     强制退出，放弃修改&lt;br&gt;查找替换&lt;br&gt;/pattern     向后搜索字符串pattern&lt;br&gt;?pattern     向前搜索字符串pattern&lt;br&gt;n     下一个匹配(如果是/搜索，则是向下的下一个，?搜索则是向上的下一个)&lt;br&gt;N     上一个匹配(同上)&lt;br&gt;:%s/old/new/g     搜索整个文件，将所有的old替换为new&lt;br&gt;:%s/old/new/gc     搜索整个文件，将所有的old替换为new，每次都要你确认是否替换&lt;br&gt;复制粘贴&lt;br&gt;dd     删除光标所在行&lt;br&gt;dw     删除一个字(word)&lt;br&gt;x     删除当前字符&lt;br&gt;X     删除前一个字符&lt;br&gt;D     删除到行末&lt;br&gt;yy     复制一行，此命令前可跟数字，标识复制多行，如6yy，表示从当前行开始复制6行&lt;br&gt;yw     复制一个字&lt;br&gt;y$     复制到行末&lt;br&gt;p     粘贴粘贴板的内容到当前行的下面&lt;br&gt;P     粘贴粘贴板的内容到当前行的上面&lt;br&gt;]p     有缩进的粘贴，vim会自动调节代码的缩进&lt;br&gt;“a     将内容放入/存入a寄存器，可以支持多粘贴板&lt;br&gt;附：比如常用的一个寄存器就是系统寄存器，名称为+，所以从系统粘贴板粘贴到vim中的命令为”+p,注意此处的+不表示操作符，二十一个寄存器。&lt;br&gt;移动光标&lt;br&gt;在vim中移动光标跟其他的编辑器中有很大的区别，不过一旦学会了，就会飞速的在文本中移动了。&lt;/p&gt;
&lt;p&gt;h,j,k,l     上，下，左，右&lt;br&gt;ctrl-f     上翻一页&lt;br&gt;ctrl-b     下翻一页&lt;br&gt;%     跳到与当前括号匹配的括号处，如当前在{，则跳转到与之匹配的}处&lt;br&gt;w     跳到下一个字首，按标点或单词分割&lt;br&gt;W     跳到下一个字首，长跳，如end-of-line被认为是一个字&lt;br&gt;e     跳到下一个字尾&lt;br&gt;E     跳到下一个字尾，长跳&lt;br&gt;b     跳到上一个字&lt;br&gt;B     跳到上一个字，长跳&lt;br&gt;0     跳至行首，不管有无缩进，就是跳到第0个字符&lt;br&gt;^     跳至行首的第一个字符&lt;br&gt;$     跳至行尾&lt;br&gt;gg     跳至文件的第一行&lt;br&gt;gd     跳至当前光标所在的变量的声明处&lt;br&gt;[N]G     跳到第N行，如0G，就等价于gg，100G就是第100行&lt;br&gt;fx     在当前行中找x字符，找到了就跳转至&lt;br&gt;;     重复上一个f命令，而不用重复的输入fx&lt;br&gt;tx     与fx类似，但是只是跳转到x的前一个字符处&lt;br&gt;Fx     跟fx的方向相反&lt;br&gt;),(     跳转到上/下一个语句&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;查找光标所在处的单词，向下查找&lt;h1 id=&quot;查找光标所在处的单词，向上查找&quot;&gt;&lt;a href=&quot;#查找光标所在处的单词，向上查找&quot; class=&quot;headerlink&quot; title=&quot;查找光标所在处的单词，向上查找&quot;&gt;&lt;/a&gt;查找光标所在处的单词，向上查找&lt;/h1&gt;`.     跳转至上次编辑位置&lt;br&gt;在屏幕上移动&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;H     移动光标到当前屏幕上最上边的一行&lt;br&gt;M     移动光标到当前屏幕上中间的一行&lt;br&gt;L     移动光标到当前屏幕上最下边的一行&lt;br&gt;书签&lt;br&gt;ma     把当前位置存成标签a&lt;br&gt;`a     跳转到标签a处&lt;br&gt;编辑&lt;br&gt;r     替换一个字符&lt;br&gt;J     将下一行和当前行连接为一行&lt;br&gt;cc     删除当前行并进入编辑模式&lt;br&gt;cw     删除当前字，并进入编辑模式&lt;br&gt;c$     擦除从当前位置至行末的内容，并进入编辑模式&lt;br&gt;s     删除当前字符并进入编辑模式&lt;br&gt;S     删除光标所在行并进入编辑模式&lt;br&gt;xp     交换当前字符和下一个字符&lt;br&gt;u     撤销&lt;br&gt;ctrl+r     重做&lt;br&gt;.     重复上一个编辑命令&lt;br&gt;~     切换大小写，当前字符&lt;br&gt;g~iw     切换当前字的大小写&lt;br&gt;gUiw     将当前字变成大写&lt;br&gt;guiw     将当前字变成小写&lt;/p&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;将当前行右移一个单位
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&amp;lt;&amp;lt;     将当前行左移一个单位(一个tab符)&lt;br&gt;==     自动缩进当前行&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;p&gt;插入模式&lt;br&gt;i     从当前光标处进入插入模式&lt;br&gt;I     进入插入模式，并置光标于行首&lt;br&gt;a     追加模式，置光标于当前光标之后&lt;br&gt;A     追加模式，置光标于行末&lt;br&gt;o     在当前行之下新加一行，并进入插入模式&lt;br&gt;O     在当前行之上新加一行，并进入插入模式&lt;br&gt;Esc     退出插入模式&lt;br&gt;可视模式&lt;br&gt;标记文本&lt;br&gt;v     进入可视模式，单字符模式&lt;br&gt;V     进入可视模式，行模式&lt;br&gt;ctrl+v     进入可视模式，列模式，类似于UE的列模式&lt;br&gt;o     跳转光标到选中块的另一个端点&lt;br&gt;U     将选中块中的内容转成大写&lt;br&gt;O     跳转光标到块的另一个端点&lt;br&gt;aw     选中一个字&lt;br&gt;ab     选中括号中的所有内容，包括括号本身&lt;br&gt;aB     选中{}括号中的所有内容&lt;br&gt;ib     选中括号中的内容，不含括号&lt;br&gt;iB     选中{}中的内容，不含{}&lt;/p&gt;
&lt;p&gt;对标记进行动作&lt;/p&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;块右移
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&amp;lt;     块左移&lt;br&gt;y     复制块&lt;br&gt;d     删除块&lt;br&gt;~     切换块中内容的大小写&lt;/p&gt;
&lt;/blockquote&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;高级一些的编辑器，都会包含宏功能，vim当然不能缺少了，在vim中使用宏是非常方便的：&lt;/p&gt;
&lt;p&gt;:qx     开始记录宏，并将结果存入寄存器x&lt;br&gt;q     退出记录模式&lt;br&gt;@x     播放记录在x寄存器中的宏命令&lt;br&gt;稍微解释一下，当在normal模式下输入:qx后，你对文本的所有编辑动作将会被记录下来，再次输入q即退出了记录模&lt;br&gt;式，然后输入@x对刚才记录下来的命令进行重复，此命令后可跟数字，表示要重复多少次，比如@x20，可以重复20次。这个在文本的批处理中是非常有用的。&lt;br&gt;同时编辑多个文件&lt;br&gt;在vim众多的插件中，有一个叫minibuffer的插件，就是下面所说的标签页功能了，可以支持同时编辑多个文件。&lt;br&gt;标签命令&lt;/p&gt;
&lt;p&gt;:tabe fn     在一个新的标签页中编辑文件fn&lt;br&gt;gt     切换到下一个标签页&lt;br&gt;gT     切换到上一个标签页&lt;br&gt;:tabr     切换到第一个标签页&lt;br&gt;:tabl     切换到最后一个标签页&lt;br&gt;:tabm [N]     把当前tab移动到第N个tab之后&lt;br&gt;对，正如你所想象的那样，跟eclipse, ue等的标签页是一个意思！&lt;br&gt;窗口命令&lt;br&gt;ctrl+w s     水平分割窗口&lt;br&gt;ctrl+w w     切换窗口&lt;br&gt;ctrl+w q     退出当前窗口(由于同时有多个文件，此命令不会影响其他窗口)&lt;br&gt;ctrl+w v     垂直分割窗口&lt;br&gt;其他&lt;br&gt;vim在保存之前不会对文件做实际的修改，只是加载到缓冲区中，对文件的编辑其实是对缓冲区的编辑，直到:w时才会存入物理文件。&lt;br&gt;
    
    </summary>
    
      <category term="Linux命令" scheme="http://yoursite.com/categories/Linux%E5%91%BD%E4%BB%A4/"/>
    
    
      <category term="VIM" scheme="http://yoursite.com/tags/VIM/"/>
    
  </entry>
  
  <entry>
    <title>数据抽样问题(蓄水池抽样)</title>
    <link href="http://yoursite.com/2016/07/29/%E6%95%B0%E6%8D%AE%E6%8A%BD%E6%A0%B7%E9%97%AE%E9%A2%98(%E8%93%84%E6%B0%B4%E6%B1%A0%E6%8A%BD%E6%A0%B7)/"/>
    <id>http://yoursite.com/2016/07/29/数据抽样问题(蓄水池抽样)/</id>
    <published>2016-07-28T16:00:00.000Z</published>
    <updated>2016-08-02T07:07:28.000Z</updated>
    
    <content type="html">&lt;h1 id=&quot;海量数据中随机抽取一行&quot;&gt;&lt;a href=&quot;#海量数据中随机抽取一行&quot; class=&quot;headerlink&quot; title=&quot;海量数据中随机抽取一行&quot;&gt;&lt;/a&gt;海量数据中随机抽取一行&lt;/h1&gt;&lt;p&gt;题目：如何从n个对象（可以依次看到这n个对象，但事先不知道n的值）中随机选择一个？具体来说，如何在事先不知道文本行数的情况下读取该文件，从中随机抽取一行？&lt;br&gt;解析：该抽样叫蓄水池抽样。因为不可以事先知道n的大小，所以不能直接使用随机数。因为是随机抽样，所以每行被抽取的概率为1/n。我们以1的概率抽取第一行存储为s，以1/2的概率抽取第二行并替换s…以1/n的概率抽取第n行，并替换s。代码如下:&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;import sys&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;import random&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;def randomSampling():&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    s = &amp;apos;&amp;apos;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    i = 1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    for line in sys.stdin:&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        if i == 1:&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            s = line.strip()&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        else:&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            if (random.randint(1, i) == 1): # 以1/k的概率被抽取到&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                s = line.strip()&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        i = i + 1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    return s&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;if __name__ == &amp;apos;__main__&amp;apos;:&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    print randomSampling()&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h1 id=&quot;题目：从海量文本中抽取k行，使得每行被抽取的概率相等。&quot;&gt;&lt;a href=&quot;#题目：从海量文本中抽取k行，使得每行被抽取的概率相等。&quot; class=&quot;headerlink&quot; title=&quot;题目：从海量文本中抽取k行，使得每行被抽取的概率相等。&quot;&gt;&lt;/a&gt;题目：从海量文本中抽取k行，使得每行被抽取的概率相等。&lt;/h1&gt;&lt;p&gt;分析：使用蓄水池抽样，先抽取k行并保存到集合set中。以k/k＋1的概率抽取第k＋1行并替换掉set[0]，以k/k+2的概率抽取第k＋2行并替换掉第set[1]行。以k/k+m对概率抽取第k+m行，并替换掉set[(k+m)%k]行。每行依然是等概率选取.&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;import sys&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;import random&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;def randomSampling(k):&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    myset = []&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    i = 1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    for line in sys.stdin:&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        if i &amp;lt;= k:&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            myset.append(line.strip())&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        else:&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            if (random.randint(1, i) &amp;lt;= k):&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                myset[i % k] = line.strip()&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        i += 1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    return myset&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;if __name__ == &amp;apos;__main__&amp;apos;:&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    for line in randomSampling(3):&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        print line.strip()&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;海量数据中随机抽取一行&quot;&gt;&lt;a href=&quot;#海量数据中随机抽取一行&quot; class=&quot;headerlink&quot; title=&quot;海量数据中随机抽取一行&quot;&gt;&lt;/a&gt;海量数据中随机抽取一行&lt;/h1&gt;&lt;p&gt;题目：如何从n个对象（可以依次看到这n个对象，但事先不知道n的值）中随机选择一个？具体来说，如何在事先不知道文本行数的情况下读取该文件，从中随机抽取一行？&lt;br&gt;解析：该抽样叫蓄水池抽样。因为不可以事先知道n的大小，所以不能直接使用随机数。因为是随机抽样，所以每行被抽取的概率为1/n。我们以1的概率抽取第一行存储为s，以1/2的概率抽取第二行并替换s…以1/n的概率抽取第n行，并替换s。代码如下:&lt;br&gt;
    
    </summary>
    
      <category term="随机抽样算法" scheme="http://yoursite.com/categories/%E9%9A%8F%E6%9C%BA%E6%8A%BD%E6%A0%B7%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="蓄水池问题" scheme="http://yoursite.com/tags/%E8%93%84%E6%B0%B4%E6%B1%A0%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>利用word2vec作词聚类</title>
    <link href="http://yoursite.com/2016/07/25/%E5%88%A9%E7%94%A8word2vec%E4%BD%9C%E8%AF%8D%E8%81%9A%E7%B1%BB/"/>
    <id>http://yoursite.com/2016/07/25/利用word2vec作词聚类/</id>
    <published>2016-07-24T16:00:00.000Z</published>
    <updated>2016-07-28T09:40:54.000Z</updated>
    
    <content type="html">&lt;p&gt;前段时间做句子主干词识别，其中有一个特征是聚类编号，即对表达意向相近的词归为一个编号，这样对于一些未登录词来说该特征显得十分重要。这就用到了word2vec工具，也就是将词语向量化，然后根据欧几里得距离或者余弦距离并使用k-means聚类算法对词语聚类。下面介绍word2vec的使用方法。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;运行过程&quot;&gt;&lt;a href=&quot;#运行过程&quot; class=&quot;headerlink&quot; title=&quot;运行过程&quot;&gt;&lt;/a&gt;运行过程&lt;/h1&gt;&lt;p&gt;首先我们将google word2vec项目源码checkout 到本机，具体地址是&lt;a href=&quot;http://word2vec.googlecode.com/svn/trunk/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://word2vec.googlecode.com/svn/trunk/&lt;/a&gt;&lt;br&gt;进入目录，命令行输入make指令，进行编译。&lt;br&gt;这样我们就可以开始使用，word2vec工具了。&lt;br&gt;假定我语料名称为test.txt且在word2vec目录中。输入命令：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;./word2vec -train test.txt -output vectors.bin -cbow 0 -size 200 \&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;-window 5 -negative 0 -hs 1 -sample 1e-3 -threads 12 -binary 1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;以上命令表示的是输入文件是test.txt，输出文件是vectors.bin，不使用cbow模型，默认为Skip-Gram模型。 每个单词的向量维度是200，训练的窗口大小为5就是考虑一个词前五个和后五个词语（实际代码中还有一个随机选窗口的过程，窗口大小&amp;lt;=5）。不使用NEG方法，使用HS方法。-sampe指的是采样的阈值，如果一个词语在训练样本中出现的频率越大，那么就越会被采样。-binary为1指的是结果二进制存储，为0是普通存储（普通存储的时候是可以打开看到词语和对应的向量的）除了以上命令中的参数，word2vec还有几个参数对我们比较有用比如-alpha设置学习速率，默认的为0.025. –min-count设置最低频率，默认是5，如果一个词语在文档中出现的次数小于5，那么就会丢弃。-classes设置聚类个数，看了一下源码用的是k-means聚类的方法。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;前段时间做句子主干词识别，其中有一个特征是聚类编号，即对表达意向相近的词归为一个编号，这样对于一些未登录词来说该特征显得十分重要。这就用到了word2vec工具，也就是将词语向量化，然后根据欧几里得距离或者余弦距离并使用k-means聚类算法对词语聚类。下面介绍word2vec的使用方法。&lt;br&gt;
    
    </summary>
    
      <category term="深度学习" scheme="http://yoursite.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="聚类" scheme="http://yoursite.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E8%81%9A%E7%B1%BB/"/>
    
    
      <category term="word2vec" scheme="http://yoursite.com/tags/word2vec/"/>
    
  </entry>
  
  <entry>
    <title>依存句法分析</title>
    <link href="http://yoursite.com/2016/07/24/%E4%BE%9D%E5%AD%98%E5%8F%A5%E6%B3%95%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2016/07/24/依存句法分析/</id>
    <published>2016-07-23T16:00:00.000Z</published>
    <updated>2016-07-26T05:48:30.000Z</updated>
    
    <content type="html">&lt;p&gt;主要进行句子的依存分析，标注出句子中各词语之间的语法关系，如下图，如SBV主谓关系，VOB动宾关系，COO并列关系等，得到的依存关系可以用于其他多项NLP任务，如信息抽取、情感分析、自动问答、机器翻译等。&lt;br&gt;&lt;img src=&quot;images/jufafenxi.png&quot; alt=&quot;image&quot;&gt;&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;依存文法最早L.Tesniere在其著作《结构句法基础》（1959年）中提出，通过分析语言单位内成分之间的依存关系揭示其句法结构，主张句子中核心动词是支配其它成分的中心成分，而它本身却不受其它任何成分的支配，所有受支配成分都以某种依存关系从属于支配者。依存语法中关于依存关系有四条公理，在处理中文信息的研究中，中国学者提出了依存关系的第五条公理，如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个句子中只有一个成分是独立的；&lt;/li&gt;
&lt;li&gt;其它成分直接依存于某一成分；&lt;/li&gt;
&lt;li&gt;任何一个成分都不能依存与两个或两个以上的成分；&lt;/li&gt;
&lt;li&gt;如果A成分直接依存于B成分，而C成分在句中位于A和B之间，那么C或者直接依存于B，或者直接依存于A和B之间的某一成分；&lt;/li&gt;
&lt;li&gt;中心成分左右两面的其它成分相互不发生关系。&lt;br&gt;句子成分间相互支配与被支配、依存与被依存的现象普遍存在于汉语的词汇（合成语）、短语、单句、复合直到句群的各级能够独立运用的语言单位之中，这一特点为依存关系的普遍性，依存句法分析可以反映出句子各成分之间的语义修饰关系，它可以获得长距离的搭配信息，并与句子成分的物理位置无关。&lt;h1 id=&quot;算法&quot;&gt;&lt;a href=&quot;#算法&quot; class=&quot;headerlink&quot; title=&quot;算法&quot;&gt;&lt;/a&gt;算法&lt;/h1&gt;当前一种主流的思路是Transition-based的依存分析，定义一个栈结构，以及一些动作，这些动作分别是句子中元素的入栈和出栈（出栈动作包括出栈元素与栈顶元素的依存边），然后训练一个分类器，对于特定状态，预测合适动作。&lt;br&gt;动作包括：&lt;/li&gt;
&lt;li&gt;SHIFT，从原句子中取一个词入栈&lt;/li&gt;
&lt;li&gt;LEFT-ARC(R)，栈顶第二个元素出栈，出站后，出栈元素为子节点，栈顶元素为父节点，边类型为R&lt;/li&gt;
&lt;li&gt;RIGHT-ARC(R)，栈顶第一个元素出栈，出站后，出栈元素为子节点，栈顶元素为父节点，边类型为R&lt;br&gt;&lt;img src=&quot;images/image2.png&quot; alt=&quot;ima&quot;&gt;&lt;br&gt;&lt;a href=&quot;1.pdf&quot;&gt;论文&lt;/a&gt;&lt;br&gt;当前大部分研究集中在动作选择时候的分类器设计和特征选择上。&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;主要进行句子的依存分析，标注出句子中各词语之间的语法关系，如下图，如SBV主谓关系，VOB动宾关系，COO并列关系等，得到的依存关系可以用于其他多项NLP任务，如信息抽取、情感分析、自动问答、机器翻译等。&lt;br&gt;&lt;img src=&quot;images/jufafenxi.png&quot; alt=&quot;image&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="句法分析" scheme="http://yoursite.com/categories/%E5%8F%A5%E6%B3%95%E5%88%86%E6%9E%90/"/>
    
    
      <category term="句法树" scheme="http://yoursite.com/tags/%E5%8F%A5%E6%B3%95%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>使用CRF++用于中文命名实体识别</title>
    <link href="http://yoursite.com/2016/07/22/%E4%BD%BF%E7%94%A8CRF++%E7%94%A8%E4%BA%8E%E4%B8%AD%E6%96%87%E5%91%BD%E5%90%8D%E5%AE%9E%E4%BD%93%E8%AF%86%E5%88%AB/"/>
    <id>http://yoursite.com/2016/07/22/使用CRF++用于中文命名实体识别/</id>
    <published>2016-07-21T16:00:00.000Z</published>
    <updated>2016-07-25T08:00:53.000Z</updated>
    
    <content type="html">&lt;h1 id=&quot;1-语料格式&quot;&gt;&lt;a href=&quot;#1-语料格式&quot; class=&quot;headerlink&quot; title=&quot;1.语料格式&quot;&gt;&lt;/a&gt;1.语料格式&lt;/h1&gt;&lt;p&gt;CRF++ 可以用于分词、词性标注和命名实体识别等任务。&lt;br&gt;官方文档: &lt;a href=&quot;https://taku910.github.io/crfpp/&quot; title=&quot;CRF++&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;/a&gt;&lt;br&gt;我们使用msra 2007用于命名实体识别的训练集和测试集，分为3个类别：人名(PER)、地名(LOC)、机构名(ORG),采用标准的BIEO方式处理，格式如下：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;是	O&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;根	O&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;据	O&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;宋	B-PER&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;神	I-PER&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;宗	E-PER&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;时	O&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;，	O&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;官	O&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;拜	O&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;礼	B-ORG&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;部	E-ORG&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;郎	O&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;杨	B-PER&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;次	I-PER&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;公	E-PER&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;的	O&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;“	O&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;牧	O&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;牛	O&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;颂	O&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;”	O&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;2-模板构建&quot;&gt;&lt;a href=&quot;#2-模板构建&quot; class=&quot;headerlink&quot; title=&quot;2.模板构建&quot;&gt;&lt;/a&gt;2.模板构建&lt;/h1&gt;&lt;p&gt;例如，对于模板:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;# Unigram&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;U00:%x[-2,0]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;U01:%x[-1,0]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;U02:%x[0,0]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;U03:%x[1,0]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;U04:%x[2,0]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;U05:%x[-2,0]/%x[-1,0]/%x[0,0]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;U06:%x[-1,0]/%x[0,0]/%x[1,0]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;U07:%x[0,0]/%x[1,0]/%x[2,0]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;U08:%x[-1,0]/%x[0,0]                                          &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;U09:%x[0,0]/%x[1,0]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;# Bigram&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;B&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;在特征模板文件中，每一行(如U00:%x[-2,0]）代表一个特征，而宏“%x[行位置,列位置]”则代表了相对于当前指向的token的行偏移和列的绝对位置.&lt;br&gt;CRF++里将特征分成两种类型，一种是Unigram的，“U”起头，另外一种是Bigram的，“B”起头。对于Unigram的特征，假如一个特征模板是”U01:%x[-1,0]“, CRF++会自动的生成一组特征函数(func1 … funcN) 集合:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;func1 = if (output = B and feature=&amp;quot;U01&amp;quot;) return 1 else return 0&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;func2 = if (output = I and feature=&amp;quot;U01&amp;quot;) return 1 else return 0&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;func3 = if (output = E and feature=&amp;quot;U01&amp;quot;) return 1 else return 0&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;....&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;生成的特征函数的数目 = (L * N)，其中L是输出的类型的个数，这里是B,I,E这几个tag，N是通过模板扩展出来的所有单个字符串(特征）的个数。&lt;br&gt;而Bigram特征主要是当前的token和前面一个位置token的自动组合生成的bigram特征集合。最后需要注意的是U01和U02这些标志位，与特征token组合到一起主要是区分“U01:問”和“U02:問”这类特征，虽然抽取的”字”特征是一样的，但是在CRF++中这是有区别的特征。&lt;/p&gt;
&lt;h1 id=&quot;3-执行命令&quot;&gt;&lt;a href=&quot;#3-执行命令&quot; class=&quot;headerlink&quot; title=&quot;3.执行命令&quot;&gt;&lt;/a&gt;3.执行命令&lt;/h1&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;../../crf_learn -f 3 -c 4.0 template train.data model  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;../../crf_test -m model test.data  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;../../crf_learn -a MIRA -f 3 template train.data model  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;../../crf_test -m model test.data&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h1 id=&quot;4-执行结果&quot;&gt;&lt;a href=&quot;#4-执行结果&quot; class=&quot;headerlink&quot; title=&quot;4.执行结果&quot;&gt;&lt;/a&gt;4.执行结果&lt;/h1&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;23&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;24&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;CRF++: Yet Another CRF Tool Kit&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;Copyright(C) 2005 Taku Kudo, All rights reserved.&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;reading training data: 100.. 200.. 300.. 400.. 500.. 600.. 700.. 800.. &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;Done! 1.94 s&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;Number of sentences: 823&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;Number of features:  1075862&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;Number of thread(s): 1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;Freq:                1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;eta:                 0.00010&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;C:                   1.00000&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;shrinking size:      20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;Algorithm:           CRF&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;iter=0 terr=0.99103 serr=1.00000 obj=54318.36623 diff=1.00000&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;iter=1 terr=0.35260 serr=0.98177 obj=44996.53537 diff=0.17161&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;iter=2 terr=0.35260 serr=0.98177 obj=21032.70195 diff=0.53257&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;iter=3 terr=0.23879 serr=0.94532 obj=13642.32067 diff=0.35138&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;iter=4 terr=0.15324 serr=0.88700 obj=8985.70071 diff=0.34134&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;iter=5 terr=0.11605 serr=0.80680 obj=7118.89846 diff=0.20775&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;iter=6 terr=0.09305 serr=0.72175 obj=5531.31015 diff=0.22301&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;iter=7 terr=0.08132 serr=0.68408 obj=4618.24644 diff=0.16507&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;iter=8 terr=0.06228 serr=0.59174 obj=3742.93171 diff=0.18953&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;其中：&lt;br&gt;iter: 迭代的次数&lt;br&gt;terr: 预测的标注错误率&lt;br&gt;serr: 预测的句子标注错误率&lt;br&gt;obj: 当前目标值，当达到一定值时，迭代停止&lt;br&gt;diff: 与上一次obj的相对diff&lt;br&gt;有4个可调的参数来控制训练过程:&lt;br&gt;-a CRF-L2 or CRF-L1:正则化项设置&lt;br&gt;-c float: 用于平衡过拟合和欠拟合&lt;br&gt;-f NUM: 用于控制迭代的次数，不少于NUM次&lt;br&gt;-p NUM: 用于控制线程的个数&lt;br&gt;CRF++ 支持single-best MIRA training&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;crf_test -v1 -m model test.data| head&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;-v1: 显示预测的目标概率&lt;br&gt;-v2: 显示所有的预测概率&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-语料格式&quot;&gt;&lt;a href=&quot;#1-语料格式&quot; class=&quot;headerlink&quot; title=&quot;1.语料格式&quot;&gt;&lt;/a&gt;1.语料格式&lt;/h1&gt;&lt;p&gt;CRF++ 可以用于分词、词性标注和命名实体识别等任务。&lt;br&gt;官方文档: &lt;a href=&quot;https://taku910.github.io/crfpp/&quot; title=&quot;CRF++&quot;&gt;&lt;/a&gt;&lt;br&gt;我们使用msra 2007用于命名实体识别的训练集和测试集，分为3个类别：人名(PER)、地名(LOC)、机构名(ORG),采用标准的BIEO方式处理，格式如下：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;是	O&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;根	O&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;据	O&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;宋	B-PER&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;神	I-PER&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;宗	E-PER&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;时	O&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;，	O&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;官	O&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;拜	O&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;礼	B-ORG&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;部	E-ORG&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;郎	O&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;杨	B-PER&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;次	I-PER&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;公	E-PER&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;的	O&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;“	O&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;牧	O&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;牛	O&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;颂	O&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;”	O&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="命名实体识别" scheme="http://yoursite.com/categories/%E5%91%BD%E5%90%8D%E5%AE%9E%E4%BD%93%E8%AF%86%E5%88%AB/"/>
    
    
      <category term="CRF" scheme="http://yoursite.com/tags/CRF/"/>
    
  </entry>
  
  <entry>
    <title>通用命名实体识别方法及步骤</title>
    <link href="http://yoursite.com/2016/07/15/%E9%80%9A%E7%94%A8%E5%91%BD%E5%90%8D%E5%AE%9E%E4%BD%93%E8%AF%86%E5%88%AB%E6%96%B9%E6%B3%95%E5%8F%8A%E6%AD%A5%E9%AA%A4/"/>
    <id>http://yoursite.com/2016/07/15/通用命名实体识别方法及步骤/</id>
    <published>2016-07-14T16:00:00.000Z</published>
    <updated>2016-07-18T02:43:27.000Z</updated>
    
    <content type="html">&lt;h1 id=&quot;一、项目简介：&quot;&gt;&lt;a href=&quot;#一、项目简介：&quot; class=&quot;headerlink&quot; title=&quot;一、项目简介：&quot;&gt;&lt;/a&gt;一、项目简介：&lt;/h1&gt;&lt;p&gt;实体识别是nlp领域的基础工作，但是，目前了解到实体识别相关的项目主要都是基于词表来实现的。虽然词表的准确率很高，但是，词表的挖掘和维护的工作量也将很大，基于词表主要问题：1，词表覆盖率不全，需要不断的更新挖掘新词来补充词表；2，词表数目过大，随着业务的不断发展，挖掘的新词需要不断的扩充到词表中，词表会越来越大；3，词表的增大也伴随着维护的困难。所以，本项目的主要目的是从纯模型的角度来解决以上问题。传统的实体识别项目主要解决的是人名，地名，机构名，这三大实体类别。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;二、主要步骤：&quot;&gt;&lt;a href=&quot;#二、主要步骤：&quot; class=&quot;headerlink&quot; title=&quot;二、主要步骤：&quot;&gt;&lt;/a&gt;二、主要步骤：&lt;/h1&gt;&lt;p&gt;首先，使用分词系统对文本进行分词，根据各自的任务不同选择是否需要词性特征。考虑本文处理的是短文本query，基本上都是一个或几个实体词，做为query。词性在这个场景下效果不是特别明显，所以，没有采用词性特征。由于使用CRF模型学习与预测，特征计算出来为连续型变量，因此，对结果进行离散化处理，分析各个特征的分布，对特征离散化结果再进一步合并处理。实体识别任务等同于实体边界识别，所以在边界特征的选取上对最终效果会有非常明显的影响。主要提供了一些通用的边界特征和紧密度特征的提取程序。 &lt;/p&gt;
&lt;h2 id=&quot;1-特征提取&quot;&gt;&lt;a href=&quot;#1-特征提取&quot; class=&quot;headerlink&quot; title=&quot;1.特征提取&quot;&gt;&lt;/a&gt;1.特征提取&lt;/h2&gt;&lt;p&gt;左熵：表示的是当前词，左边搭配的词数量的多少。左熵的值越大，表示这个词越有可能是右边界（实体的后缀词），与左边的词可能构成实体。&lt;br&gt;右熵：表示的是当前词，右边搭配词的数量的多少。右熵的值越大，表示这个词越有可能是左边界（实体前缀，或者，单独的实体），与右边的词可能构成实体。&lt;br&gt;点互信息：表示的是两个词的紧密度，本文特征提取的是当前词与前一个词的互信息。值越大，表示两个词越紧密，可能是一个实体词或实体词的一部分。等于零，表示两个词相互独立。值越小，表示两个词互斥出现。因为，考虑到最终互信息词表过大，所以，把小于一定阈值的互信息删除，只考虑紧密度比较大的词。&lt;br&gt;还有其他类型的特征比如，词长度，词性等特征。还有自定义的特征：实体词的前缀特征，实体词的后缀特征。可以根据需要识别的类型，从已收集的词表或者再使用一些挖掘词表的方法。从中提取后缀词，后缀字，前缀词，前缀字特征以用来辅助确定实体的边界信息。&lt;br&gt;组合特征：经测试特征模板中添加一部分组合特征对效果提升比较明显。比如增加：1，当前词的右熵与下一个词的左熵。2，当前词的后缀词特征之间的组合。其他可根据自己的应用测试不同的组合情况。&lt;/p&gt;
&lt;h2 id=&quot;2-语料标注&quot;&gt;&lt;a href=&quot;#2-语料标注&quot; class=&quot;headerlink&quot; title=&quot;2.语料标注&quot;&gt;&lt;/a&gt;2.语料标注&lt;/h2&gt;&lt;p&gt; 模型训练阶段使用提取特征框架，将主动学习中已经标记好的语料转换为CRF需要的格式。本文采用BIO标记识别的位置信息。B表示实体开始的词，I表示实体中间的词。O表示非实体词。当标记语料比较多的时候，还可以使用BIEO或BIESO这种方式来标记实体。E表示实体结束词，S表示当前词是一个实体，可以提供更为丰富的边界特征，提高边界识别的准确率。本文标记语料只有5000条数据，测试了BIEO或BIESO的方式，数据稀疏比较严重，所以还是使用BIO作为标记语料。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一、项目简介：&quot;&gt;&lt;a href=&quot;#一、项目简介：&quot; class=&quot;headerlink&quot; title=&quot;一、项目简介：&quot;&gt;&lt;/a&gt;一、项目简介：&lt;/h1&gt;&lt;p&gt;实体识别是nlp领域的基础工作，但是，目前了解到实体识别相关的项目主要都是基于词表来实现的。虽然词表的准确率很高，但是，词表的挖掘和维护的工作量也将很大，基于词表主要问题：1，词表覆盖率不全，需要不断的更新挖掘新词来补充词表；2，词表数目过大，随着业务的不断发展，挖掘的新词需要不断的扩充到词表中，词表会越来越大；3，词表的增大也伴随着维护的困难。所以，本项目的主要目的是从纯模型的角度来解决以上问题。传统的实体识别项目主要解决的是人名，地名，机构名，这三大实体类别。&lt;br&gt;
    
    </summary>
    
      <category term="命名实体识别" scheme="http://yoursite.com/categories/%E5%91%BD%E5%90%8D%E5%AE%9E%E4%BD%93%E8%AF%86%E5%88%AB/"/>
    
    
      <category term="NER" scheme="http://yoursite.com/tags/NER/"/>
    
  </entry>
  
  <entry>
    <title>通俗理解卷积神经网络(CNN)[转载]</title>
    <link href="http://yoursite.com/2016/07/11/%E9%80%9A%E4%BF%97%E7%90%86%E8%A7%A3%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C(CNN)/"/>
    <id>http://yoursite.com/2016/07/11/通俗理解卷积神经网络(CNN)/</id>
    <published>2016-07-10T16:00:00.000Z</published>
    <updated>2016-07-14T07:30:56.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;1-人工神经网络&quot;&gt;&lt;a href=&quot;#1-人工神经网络&quot; class=&quot;headerlink&quot; title=&quot;1.人工神经网络&quot;&gt;&lt;/a&gt;1.人工神经网络&lt;/h2&gt;&lt;h3 id=&quot;1-1神经元&quot;&gt;&lt;a href=&quot;#1-1神经元&quot; class=&quot;headerlink&quot; title=&quot;1.1神经元&quot;&gt;&lt;/a&gt;1.1神经元&lt;/h3&gt;&lt;p&gt;神经网络由大量的神经元相互连接而成。每个神经元接受线性组合的输入后，最开始只是简单的线性加权，后来给每个神经元加上了非线性的激活函数，从而进行非线性变换后输出。每两个神经元之间的连接代表加权值，称之为权重（weight）。不同的权重和激活函数，则会导致神经网络不同的输出。&lt;/p&gt;
&lt;p&gt;举个手写识别的例子，给定一个未知数字，让神经网络识别是什么数字。此时的神经网络的输入由一组被输入图像的像素所激活的输入神经元所定义。在通过非线性激活函数进行非线性变换后，神经元被激活然后被传递到其他神经元。重复这一过程，直到最后一个输出神经元被激活。从而识别当前数字是什么字。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;br&gt;    神经网络的每个神经元如下&lt;br&gt;    &lt;img src=&quot;http://img.blog.csdn.net/20160703112618929&quot; alt=&quot;神经网络示例&quot;&gt;&lt;br&gt;类似wx + b的形式，其中&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;a1~an为输入向量，当然，也常用x1~xn表示输入&lt;/li&gt;
&lt;li&gt;w1~wn为权重&lt;/li&gt;
&lt;li&gt;b为偏置bias&lt;/li&gt;
&lt;li&gt;f 为激活函数&lt;/li&gt;
&lt;li&gt;&lt;p&gt;t 为输出&lt;br&gt;  如果只是上面这样一说，估计以前没接触过的十有八九又必定迷糊了。事实上，上述简单模型可以追溯到20世纪50/60年代的感知器，可以把感知器理解为一个根据不同因素、以及各个因素的重要性程度而做决策的模型。&lt;/p&gt;
&lt;p&gt;  举个例子，这周末北京有一草莓音乐节，那去不去呢？决定你是否去有3个因素，这三个因素可以对应三个输入，分别用x1、x2、x3表示。此外，这三个因素对做决策的影响程度不一样，各自的影响程度用权重w1、w2、w3表示。一般来说，音乐节的演唱嘉宾会非常影响你去不去，唱得好的前提下 即便天气不好、没人陪同都可忍受，但如果唱得不好还不如你上台唱呢。所以，我们可以如下表示：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;x1：是否有喜欢的演唱嘉宾。x1 = 1 你喜欢这些嘉宾，x1 = 0 你不喜欢这些嘉宾。嘉宾因素的权重w1 = 5&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;x2：天气好坏。x2 = 1 天气好，x2 = 0 天气不好。天气权重w2 = 2。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;x3：是否有人陪你同去。x3 = 1 有人陪你同去，x2 = 0 没人陪你同去。是否有陪同的权重w3 = 3。&lt;br&gt;  这样，咱们的决策模型函数便建立起来了：f(x) = g( w1&lt;em&gt;x1 + w2&lt;/em&gt;x2 + w3*x3 + b )，g表示激活函数。然后设定一个阈值，如果这些加权输入值的和[ 即f(x) ]超过这个阈值，就输出1：代表去参加音乐节，否则输出0：代表不去参加音乐节。&lt;br&gt;  一开始，激活函数是线性函数，导致所有的变换都是线性变换，比如if x &amp;lt; 0 f(x) = 0; if x &amp;gt; 0,f(x) = 1，输出都是输入的线性变换。后来实际应用中发现，线性激活函数太过局限，于是人们引入了非线性激活函数。&lt;/p&gt;
&lt;h3 id=&quot;1-2神经网络&quot;&gt;&lt;a href=&quot;#1-2神经网络&quot; class=&quot;headerlink&quot; title=&quot;1.2神经网络&quot;&gt;&lt;/a&gt;1.2神经网络&lt;/h3&gt;&lt;p&gt;将下图的这种单个神经元&lt;br&gt;&lt;img src=&quot;http://img.blog.csdn.net/20160703140734967&quot; alt=&quot;神经网络示例&quot;&gt;&lt;br&gt;组织在一起，便形成了神经网络。下图便是一个三层神经网络结构&lt;br&gt;&lt;img src=&quot;http://img.blog.csdn.net/20160703140745657&quot; alt=&quot;神经网络示例&quot;&gt;&lt;br&gt;上图中最左边的原始输入信息称之为输入层，最右边的神经元称之为输出层（上图中输出层只有一个神经元），中间的叫隐藏层。&lt;/p&gt;
&lt;p&gt;  啥叫输入层、输出层、隐藏层呢？&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;输入层（Input layer），众多神经元（Neuron）接受大量非线形输入讯息。输入的讯息称为输入向量。&lt;br&gt;输出层（Output layer），讯息在神经元链接中传输、分析、权衡，形成输出结果。输出的讯息称为输出向量。&lt;br&gt;隐藏层（Hidden layer），简称“隐层”，是输入层和输出层之间众多神经元和链接组成的各个层面。如果有多个隐藏层，则意味着多个激活函数。&lt;br&gt;    同时，每一层都可能由单个或多个神经元组成，每一层的输出将会作为下一层的输入数据。比如下图中间隐藏层来说，隐藏层的3个神经元a1、a2、a3皆各自接受来自多个不同权重的输入，接着，a1、a2、a3又在自身各自不同权重的影响下 成为的输出层的输入，最终由输出层输出最终结果。&lt;br&gt; &lt;img src=&quot;http://img.blog.csdn.net/20160703110336151&quot; alt=&quot;神经网络示例&quot;&gt;&lt;br&gt;  &lt;img src=&quot;http://img.blog.csdn.net/20160703113851013&quot; alt=&quot;神经网络示例&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;2-CNN之卷积计算层&quot;&gt;&lt;a href=&quot;#2-CNN之卷积计算层&quot; class=&quot;headerlink&quot; title=&quot;2.CNN之卷积计算层&quot;&gt;&lt;/a&gt;2.CNN之卷积计算层&lt;/h2&gt;&lt;h3 id=&quot;2-1什么是卷积&quot;&gt;&lt;a href=&quot;#2-1什么是卷积&quot; class=&quot;headerlink&quot; title=&quot;2.1什么是卷积&quot;&gt;&lt;/a&gt;2.1什么是卷积&lt;/h3&gt;&lt;p&gt; 首先，我们来了解下什么是卷积操作。&lt;br&gt;    对图像（不同的数据窗口数据）和滤波矩阵（一组固定的权重：因为每个神经元的权重固定，所以又可以看做一个恒定的滤波器filter）做内积（逐个元素相乘再求和）的操作就是所谓的『卷积』操作，也是卷积神经网络的名字来源。&lt;br&gt;    比如下图中，图中左边部分是原始输入数据，图中中间部分是滤波器filter，图中右边是输出的新的二维数据。&lt;br&gt; &lt;img src=&quot;http://img.blog.csdn.net/20160702215705128&quot; alt=&quot;神经网络示例&quot;&gt;&lt;br&gt;中间滤波器filter与数据窗口做内积，其具体计算过程则是：4&lt;em&gt;0 + 0&lt;/em&gt;0 + 0&lt;em&gt;0 + 0&lt;/em&gt;0 + 0&lt;em&gt;1 + 0&lt;/em&gt;1 + 0&lt;em&gt;0 + 0&lt;/em&gt;1 + -4*2 = -8&lt;/p&gt;
&lt;h3 id=&quot;2-2动态卷积图&quot;&gt;&lt;a href=&quot;#2-2动态卷积图&quot; class=&quot;headerlink&quot; title=&quot;2.2动态卷积图&quot;&gt;&lt;/a&gt;2.2动态卷积图&lt;/h3&gt;&lt;p&gt;在CNN中，滤波器filter对局部输入数据进行卷积计算。每计算完一个数据窗口内的局部数据后，数据窗口不断平移滑动，直到计算完所有数据。这个过程中，有这么几个参数：&lt;br&gt;　　a. 深度depth：神经元个数，决定输出的depth厚度。&lt;br&gt;　　b. 步长stride：决定滑动多少步可以到边缘&lt;br&gt;　　c. 填充值zero-padding：在外围边缘补充若干圈0，方便从初始位置以步长为单位可以刚好滑倒末尾位置，通俗地讲就是为了总长能被步长整除。&lt;br&gt;&lt;img src=&quot;http://img.blog.csdn.net/20160707204048899&quot; alt=&quot;神经网络示例&quot;&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-人工神经网络&quot;&gt;&lt;a href=&quot;#1-人工神经网络&quot; class=&quot;headerlink&quot; title=&quot;1.人工神经网络&quot;&gt;&lt;/a&gt;1.人工神经网络&lt;/h2&gt;&lt;h3 id=&quot;1-1神经元&quot;&gt;&lt;a href=&quot;#1-1神经元&quot; class=&quot;headerlink&quot; title=&quot;1.1神经元&quot;&gt;&lt;/a&gt;1.1神经元&lt;/h3&gt;&lt;p&gt;神经网络由大量的神经元相互连接而成。每个神经元接受线性组合的输入后，最开始只是简单的线性加权，后来给每个神经元加上了非线性的激活函数，从而进行非线性变换后输出。每两个神经元之间的连接代表加权值，称之为权重（weight）。不同的权重和激活函数，则会导致神经网络不同的输出。&lt;/p&gt;
&lt;p&gt;举个手写识别的例子，给定一个未知数字，让神经网络识别是什么数字。此时的神经网络的输入由一组被输入图像的像素所激活的输入神经元所定义。在通过非线性激活函数进行非线性变换后，神经元被激活然后被传递到其他神经元。重复这一过程，直到最后一个输出神经元被激活。从而识别当前数字是什么字。&lt;br&gt;
    
    </summary>
    
      <category term="Deep Learning" scheme="http://yoursite.com/categories/Deep-Learning/"/>
    
    
      <category term="Deep Learning" scheme="http://yoursite.com/tags/Deep-Learning/"/>
    
  </entry>
  
  <entry>
    <title>C/C++中计算程序运行时间的方法</title>
    <link href="http://yoursite.com/2016/07/09/C:C++%E4%B8%AD%E8%AE%A1%E7%AE%97%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E6%97%B6%E9%97%B4%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2016/07/09/C:C++中计算程序运行时间的方法/</id>
    <published>2016-07-08T16:00:00.000Z</published>
    <updated>2016-07-14T07:07:00.000Z</updated>
    
    <content type="html">&lt;p&gt;最近写完程序在公司需要测试每个句子输入到返回结果的运行时间，刚开始使用clock()函数是精确到毫秒，但是经过测试然并卵，总是返回0ms，程序运行时间太短，最后总结一下：&lt;/p&gt;
&lt;h3 id=&quot;精确到毫秒ms&quot;&gt;&lt;a href=&quot;#精确到毫秒ms&quot; class=&quot;headerlink&quot; title=&quot;精确到毫秒ms&quot;&gt;&lt;/a&gt;精确到毫秒ms&lt;/h3&gt;&lt;p&gt;clock()计算的是CPU执行耗时，注意是CPU！如果有多个核并行，最后的结果是每个CPU上运算时间的总和！想要精确到毫秒，可以double(end -begin)*1000/CLOCKS_PER_SEC&lt;br&gt;一般来说，只要求精确到秒的话，time是很好使的&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;#include &amp;lt;&amp;lt;/span&amp;gt;stdio.h&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;#include &amp;lt;&amp;lt;/span&amp;gt;time.h&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;int main()&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    time_t t_start, t_end;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    t_start = time(NULL) ;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    sleep(3000);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    t_end = time(NULL) ;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    printf(&amp;quot;time: %.0f s\n&amp;quot;, difftime(t_end,t_start)) ;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    return 0;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;精确到微秒us&quot;&gt;&lt;a href=&quot;#精确到微秒us&quot; class=&quot;headerlink&quot; title=&quot;精确到微秒us&quot;&gt;&lt;/a&gt;精确到微秒us&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;#include &amp;lt;&amp;lt;/span&amp;gt;stdio.h&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;#include &amp;lt;&amp;lt;/span&amp;gt;sys/time.h&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;int main() &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    struct timeval start, end;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    gettimeofday( &amp;amp;start, NULL );&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    sleep(3);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    gettimeofday( &amp;amp;end, NULL );&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    int timeuse = 1000000 * ( end.tv_sec - start.tv_sec ) + end.tv_usec -start.tv_usec;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    printf(&amp;quot;time: %d us\n&amp;quot;, timeuse);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    return 0;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;最近写完程序在公司需要测试每个句子输入到返回结果的运行时间，刚开始使用clock()函数是精确到毫秒，但是经过测试然并卵，总是返回0ms，程序运行时间太短，最后总结一下：&lt;/p&gt;
&lt;h3 id=&quot;精确到毫秒ms&quot;&gt;&lt;a href=&quot;#精确到毫秒ms&quot; class=&quot;headerlink&quot; title=&quot;精确到毫秒ms&quot;&gt;&lt;/a&gt;精确到毫秒ms&lt;/h3&gt;&lt;p&gt;clock()计算的是CPU执行耗时，注意是CPU！如果有多个核并行，最后的结果是每个CPU上运算时间的总和！想要精确到毫秒，可以double(end -begin)*1000/CLOCKS_PER_SEC&lt;br&gt;一般来说，只要求精确到秒的话，time是很好使的&lt;br&gt;
    
    </summary>
    
      <category term="C/C++" scheme="http://yoursite.com/categories/C-C/"/>
    
    
      <category term="-C/C++ -运行时间" scheme="http://yoursite.com/tags/C-C-%E8%BF%90%E8%A1%8C%E6%97%B6%E9%97%B4/"/>
    
  </entry>
  
  <entry>
    <title>利用标注语料生成决策weights</title>
    <link href="http://yoursite.com/2016/07/05/%E5%88%A9%E7%94%A8%E6%A0%87%E6%B3%A8%E8%AF%AD%E6%96%99%E7%94%9F%E6%88%90%E5%86%B3%E7%AD%96weights/"/>
    <id>http://yoursite.com/2016/07/05/利用标注语料生成决策weights/</id>
    <published>2016-07-04T16:00:00.000Z</published>
    <updated>2016-07-08T09:18:09.000Z</updated>
    
    <content type="html">&lt;p&gt;1、之前两周利用主动学习的方式训练集&lt;br&gt;2、标注数据分离一小部分作为测试集利用LR分类器调参。&lt;br&gt;3、利用最有参数训练标注语料生成特征权重weights。&lt;br&gt;3、使用weights获得主干提取demo。&lt;br&gt;周一的时候做好了主干提取的Demo初始版本，经过测试效果不太理想&lt;br&gt;分析原因：训练集过少、覆盖面过窄、稳定性不高&lt;br&gt;这周的主要工作：&lt;br&gt;1、提取多种语料库中的资源做人工语料标注&lt;br&gt;2、增加部分特征，扩大特征维度&lt;br&gt;3、特征结构统一化，例如某个词的特征用词典表示，预定义好所有的key。暂时定义如下：&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;列表内容&lt;/li&gt;
&lt;li&gt;word_0  当前词本身&lt;/li&gt;
&lt;li&gt;pos_0  当前词本身词性&lt;/li&gt;
&lt;li&gt;cluster_0 当前词本身聚类编号&lt;/li&gt;
&lt;li&gt;word_-1  当前词的前一个词本身&lt;/li&gt;
&lt;li&gt;pos_-1   当前词的前一个词词性&lt;/li&gt;
&lt;li&gt;cluster_-1   当前词的前一个词聚类编号&lt;/li&gt;
&lt;li&gt;word_1   当前词的后一个词本身&lt;/li&gt;
&lt;li&gt;pos_1    当前词的后一个词词性&lt;/li&gt;
&lt;li&gt;cluster_1   当前词的后一个词聚类编号&lt;/li&gt;
&lt;li&gt;parent_edge_0   当前词的父边关系类型&lt;/li&gt;
&lt;li&gt;child_edge_0   当前词的子边关系类型&lt;/li&gt;
&lt;li&gt;word_parent_node_0   当前词的父节点词本身&lt;/li&gt;
&lt;li&gt;pos_parent_node_0  当前词的父节点词性&lt;/li&gt;
&lt;li&gt;cluster_parent_node_0 当前词的父节点词聚类编号&lt;/li&gt;
&lt;li&gt;word_parent&lt;em&gt;node&lt;/em&gt;-1   当前词的前一个词的父节点词本身&lt;/li&gt;
&lt;li&gt;pos_parent&lt;em&gt;node&lt;/em&gt;-1  当前词的前一个词的父节点词性&lt;/li&gt;
&lt;li&gt;cluster_parent&lt;em&gt;node&lt;/em&gt;-1 当前词的前一个词的父节点词聚类编号&lt;/li&gt;
&lt;li&gt;word_parent_node_1   当前词的后一个词的父节点词本身&lt;/li&gt;
&lt;li&gt;pos_parent_node_1  当前词的后一个词的父节点词性&lt;/li&gt;
&lt;li&gt;cluster_parent_node_1 当前词的后一个词的父节点词聚类编号&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;计划下周：&lt;br&gt;把句子主干提取完善版本完成。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;1、之前两周利用主动学习的方式训练集&lt;br&gt;2、标注数据分离一小部分作为测试集利用LR分类器调参。&lt;br&gt;3、利用最有参数训练标注语料生成特征权重weights。&lt;br&gt;3、使用weights获得主干提取demo。&lt;br&gt;周一的时候做好了主干提取的Demo初始版本，经过测试效果不太理想&lt;br&gt;分析原因：训练集过少、覆盖面过窄、稳定性不高&lt;br&gt;这周的主要工作：&lt;br&gt;1、提取多种语料库中的资源做人工语料标注&lt;br&gt;2、增加部分特征，扩大特征维度&lt;br&gt;3、特征结构统一化，例如某个词的特征用词典表示，预定义好所有的key。暂时定义如下：&lt;/p&gt;
    
    </summary>
    
      <category term="句子主干提取" scheme="http://yoursite.com/categories/%E5%8F%A5%E5%AD%90%E4%B8%BB%E5%B9%B2%E6%8F%90%E5%8F%96/"/>
    
    
      <category term="逻辑回归" scheme="http://yoursite.com/tags/%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/"/>
    
      <category term="主动学习" scheme="http://yoursite.com/tags/%E4%B8%BB%E5%8A%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>通过主动学习的方法进行自动语料标注</title>
    <link href="http://yoursite.com/2016/06/24/%E9%80%9A%E8%BF%87%E4%B8%BB%E5%8A%A8%E5%AD%A6%E4%B9%A0%E7%9A%84%E6%96%B9%E6%B3%95%E8%BF%9B%E8%A1%8C%E8%87%AA%E5%8A%A8%E8%AF%AD%E6%96%99%E6%A0%87%E6%B3%A8/"/>
    <id>http://yoursite.com/2016/06/24/通过主动学习的方法进行自动语料标注/</id>
    <published>2016-06-23T16:00:00.000Z</published>
    <updated>2016-07-08T10:50:19.000Z</updated>
    
    <content type="html">&lt;p&gt;   目前正在做句子主干提取方面的工作，主要方法是构建二分类器，提取句子分词之后每个词的特征来决定分词的取舍。由于需要标注大量的训练语料，采用人工的方法费时费力，于是采用主动学习的方法实现语料标注，我实现的步骤如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;先对语料实现人工标注一部分&lt;/li&gt;
&lt;li&gt;使用机器学习训练模型如SVM、LR对已经标注的语料训练，把为标注的语料作为测试集&lt;/li&gt;
&lt;li&gt;为测试机样本产生标签及置信度（即标签的准确性的概率值）&lt;/li&gt;
&lt;li&gt;通过观察为置信度设定一个阈值，当样本中的每个分词都满足这个阈值时，我们把这个自动标注好的测试样本加入到训练集中，在测试样本中取出这个样本&lt;/li&gt;
&lt;li&gt;重复2-4步，直到剩余的测试样本中没有完全满足阈值的&lt;/li&gt;
&lt;li&gt;&lt;p&gt;输出剩余的测试样本&lt;/p&gt;
&lt;p&gt; 刚开始我觉得这种方法非常好，经过测试，大概20次迭代之后大概4/5的样本已经标注好了&lt;br&gt;经过导师指导发现这种方法并不可靠，因为你新添加的训练集也是之前训练集产生的，反复迭代只会过拟合。我们应该设定一个比较低的阈值，找到测试集中非常不确定的测试样本（所有这些测试样本的置信度很低），通常来说这些样本是最有“价值”的样本，我们对这一小部分采用人工标注，并放入到训练集中，反复几次。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;   目前正在做句子主干提取方面的工作，主要方法是构建二分类器，提取句子分词之后每个词的特征来决定分词的取舍。由于需要标注大量的训练语料，采用人工的方法费时费力，于是采用主动学习的方法实现语料标注，我实现的步骤如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;先对语料实现人工标注一部分&lt;/
    
    </summary>
    
      <category term="句子主干提取" scheme="http://yoursite.com/categories/%E5%8F%A5%E5%AD%90%E4%B8%BB%E5%B9%B2%E6%8F%90%E5%8F%96/"/>
    
    
      <category term="逻辑回归" scheme="http://yoursite.com/tags/%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/"/>
    
      <category term="主动学习" scheme="http://yoursite.com/tags/%E4%B8%BB%E5%8A%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Pagerank算法的具体实现</title>
    <link href="http://yoursite.com/2016/06/19/pagerank%E7%AE%97%E6%B3%95%E7%9A%84%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0/"/>
    <id>http://yoursite.com/2016/06/19/pagerank算法的具体实现/</id>
    <published>2016-06-18T16:00:00.000Z</published>
    <updated>2016-07-08T07:02:10.000Z</updated>
    
    <content type="html">&lt;p&gt;PageRank对网页排名的算法，曾是Google发家致富的法宝。以前虽然有实验过，但理解还是不透彻，这几天又看了一下，这里总结一下PageRank算法的基本原理。&lt;/p&gt;
&lt;h3 id=&quot;1、什么是pagerank&quot;&gt;&lt;a href=&quot;#1、什么是pagerank&quot; class=&quot;headerlink&quot; title=&quot;1、什么是pagerank&quot;&gt;&lt;/a&gt;1、什么是pagerank&lt;/h3&gt;&lt;p&gt;PageRank的Page可是认为是网页，表示网页排名，也可以认为是Larry Page(google 产品经理)，因为他是这个算法的发明者之一，还是google CEO（^_^）。PageRank算法计算每一个网页的PageRank值，然后根据这个值的大小对网页的重要性进行排序。它的思想是模拟一个悠闲的上网者，上网者首先随机选择一个网页打开，然后在这个网页上呆了几分钟后，跳转到该网页所指向的链接，这样无所事事、漫无目的地在网页上跳来跳去，PageRank就是估计这个悠闲的上网者分布在各个网页上的概率。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;2、最简单pagerank模型&quot;&gt;&lt;a href=&quot;#2、最简单pagerank模型&quot; class=&quot;headerlink&quot; title=&quot;2、最简单pagerank模型&quot;&gt;&lt;/a&gt;2、最简单pagerank模型&lt;/h3&gt;&lt;p&gt;互联网中的网页可以看出是一个有向图，其中网页是结点，如果网页A有链接到网页B，则存在一条有向边A-&amp;gt;B，下面是一个简单的示例：&lt;br&gt;&lt;img src=&quot;http://jbcdn2.b0.upaiyun.com/2014/06/ca4f4c96cd2294c797ddf585c4188074.jpg&quot; alt=&quot;pagerank示例&quot;&gt;&lt;br&gt;这个例子中只有四个网页，如果当前在A网页，那么悠闲的上网者将会各以1/3的概率跳转到B、C、D，这里的3表示A有3条出链，如果一个网页有k条出链，那么跳转任意一个出链上的概率是1/k，同理D到B、C的概率各为1/2，而B到C的概率为0。一般用转移矩阵表示上网者的跳转概率，如果用n表示网页的数目，则转移矩阵M是一个n*n的方阵；如果网页j有k个出链，那么对每一个出链指向的网页i，有M[i][j]=1/k，而其他网页的M[i][j]=0；上面示例图对应的转移矩阵如下：&lt;br&gt;&lt;img src=&quot;http://jbcdn2.b0.upaiyun.com/2014/06/4162fcd6ae797038923715cca812e3b9.jpg&quot; alt=&quot;pagerank示例&quot;&gt;&lt;br&gt;初试时，假设上网者在每一个网页的概率都是相等的，即1/n，于是初试的概率分布就是一个所有值都为1/n的n维列向量V0，用V0去右乘转移矩阵M，就得到了第一步之后上网者的概率分布向量MV0,（nXn）*(nX1)依然得到一个nX1的矩阵。下面是V1的计算过程：&lt;br&gt;&lt;img src=&quot;http://jbcdn2.b0.upaiyun.com/2014/06/4be2f7275f8b1880bbf99e08240fec7f.jpg&quot; alt=&quot;pagerank示例&quot;&gt;&lt;br&gt;注意矩阵M中M[i][j]不为0表示用一个链接从j指向i，M的第一行乘以V0，表示累加所有网页到网页A的概率即得到9/24。得到了V1后，再用V1去右乘M得到V2，一直下去，最终V会收敛，即Vn=MV(n-1)，上面的图示例，不断的迭代，最终V=[3/9,2/9,2/9,2/9]’：&lt;br&gt;&lt;img src=&quot;http://jbcdn2.b0.upaiyun.com/2014/06/2e906d4e9404a5aadf2938f001ad0ea7.jpg&quot; alt=&quot;pagerank示例&quot;&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;PageRank对网页排名的算法，曾是Google发家致富的法宝。以前虽然有实验过，但理解还是不透彻，这几天又看了一下，这里总结一下PageRank算法的基本原理。&lt;/p&gt;
&lt;h3 id=&quot;1、什么是pagerank&quot;&gt;&lt;a href=&quot;#1、什么是pagerank&quot; class=&quot;headerlink&quot; title=&quot;1、什么是pagerank&quot;&gt;&lt;/a&gt;1、什么是pagerank&lt;/h3&gt;&lt;p&gt;PageRank的Page可是认为是网页，表示网页排名，也可以认为是Larry Page(google 产品经理)，因为他是这个算法的发明者之一，还是google CEO（^_^）。PageRank算法计算每一个网页的PageRank值，然后根据这个值的大小对网页的重要性进行排序。它的思想是模拟一个悠闲的上网者，上网者首先随机选择一个网页打开，然后在这个网页上呆了几分钟后，跳转到该网页所指向的链接，这样无所事事、漫无目的地在网页上跳来跳去，PageRank就是估计这个悠闲的上网者分布在各个网页上的概率。&lt;br&gt;
    
    </summary>
    
      <category term="实体链接" scheme="http://yoursite.com/categories/%E5%AE%9E%E4%BD%93%E9%93%BE%E6%8E%A5/"/>
    
    
      <category term="PageRank" scheme="http://yoursite.com/tags/PageRank/"/>
    
      <category term="Graph Model" scheme="http://yoursite.com/tags/Graph-Model/"/>
    
  </entry>
  
  <entry>
    <title>单链表反转问题</title>
    <link href="http://yoursite.com/2016/06/15/%E5%8D%95%E9%93%BE%E8%A1%A8%E5%8F%8D%E8%BD%AC%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2016/06/15/单链表反转问题/</id>
    <published>2016-06-14T16:00:00.000Z</published>
    <updated>2016-07-17T09:39:00.000Z</updated>
    
    <content type="html">&lt;p&gt;题目：定义一个函数，输入一个链表的头结点，反转该链表并输出反转后链表的头结点。&lt;/p&gt;
&lt;h3 id=&quot;1、非递归方式实现&quot;&gt;&lt;a href=&quot;#1、非递归方式实现&quot; class=&quot;headerlink&quot; title=&quot;1、非递归方式实现&quot;&gt;&lt;/a&gt;1、非递归方式实现&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;//思路为将节点从前到后依次放到表头，最后最后的节点到了最前面,最前面的节点到了最后面  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;ListNode * ReverseList(ListNode *  head)  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#123;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   //如果链表为空或者链表中只有一个元素  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   if(head==NULL || head-&amp;gt;m_pNext==NULL)  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;       return head;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   ListNode * p=head-&amp;gt;m_pNext;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   ListNode * q=head;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   while(p!=NULL)  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   &amp;#123;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;     q-&amp;gt;m_pNext=p-&amp;gt;m_pNext;//记录下p的下一个节点  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;     p-&amp;gt;m_pNext=head;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;     head=p;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;     p=q-&amp;gt;m_pNext;//准备将p的下一个节点放到表头  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   &amp;#125;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   return head;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=&quot;330&quot; height=&quot;86&quot; src=&quot;http://music.163.com/outchain/player?type=2&amp;id=32507038&amp;auto=1&amp;height=66&quot;&gt;&lt;/iframe&gt;&lt;/p&gt;
&lt;h3 id=&quot;2、递归方式实现&quot;&gt;&lt;a href=&quot;#2、递归方式实现&quot; class=&quot;headerlink&quot; title=&quot;2、递归方式实现&quot;&gt;&lt;/a&gt;2、递归方式实现&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;ListNode * ReverseList2(ListNode * head)  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#123;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    //如果链表为空或者链表中只有一个元素  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    if(head==NULL || head-&amp;gt;m_pNext==NULL)  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        return head;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    else  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#123;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;       ListNode * newhead=ReverseList2(head-&amp;gt;m_pNext);//先反转后面的链表  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;       head-&amp;gt;m_pNext-&amp;gt;m_pNext=head;//再将当前节点设置为其然来后面节点的后续节点  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;       head-&amp;gt;m_pNext=NULL;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;       return newhead;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;3、完整的代码流程&quot;&gt;&lt;a href=&quot;#3、完整的代码流程&quot; class=&quot;headerlink&quot; title=&quot;3、完整的代码流程&quot;&gt;&lt;/a&gt;3、完整的代码流程&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;23&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;24&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;25&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;26&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;27&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;28&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;29&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;30&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;31&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;32&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;33&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;34&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;35&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;36&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;37&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;38&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;39&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;40&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;41&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;42&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;43&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;44&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;45&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;46&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;47&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;48&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;49&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;50&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;51&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;52&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;53&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;54&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;55&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;56&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;57&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;58&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;59&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;60&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;61&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;62&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;63&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;64&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;65&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;66&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;67&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;68&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;69&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;70&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;71&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;72&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;73&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;74&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;75&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;76&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;77&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;78&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;79&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;80&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;81&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;82&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;83&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;84&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;// 反转链表.cpp : 定义控制台应用程序的入口点。  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;#include &amp;quot;stdafx.h&amp;quot;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;#include  &amp;lt;iostream&amp;gt;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;using namespace std;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;//定义一个链表节点  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt; typedef struct ListNode  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#123;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    int       m_nKey;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    struct ListNode * m_pNext;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;ListNode;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;//插入一个新节点到链表中(放在链表头部)  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;void CreateList(ListNode * &amp;amp; head,int data)  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#123;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    //创建新节点  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    ListNode * p=(ListNode*)malloc(sizeof(ListNode));  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    p-&amp;gt;m_nKey=data;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    p-&amp;gt;m_pNext=NULL;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    if(head==NULL)  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#123;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        head=p;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        return;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    p-&amp;gt;m_pNext=head;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    head=p;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;void  printList(ListNode* head)  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#123;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   ListNode * p=head;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   while(p!=NULL)  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   &amp;#123;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      cout&amp;lt;&amp;lt;p-&amp;gt;m_nKey&amp;lt;&amp;lt;&amp;quot; &amp;quot;;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      p=p-&amp;gt;m_pNext;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   &amp;#125;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   cout&amp;lt;&amp;lt;endl;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;//思路为将节点从前到后依次放到表头，最后最后的节点到了最前面,最前面的节点到了最后面  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;ListNode * ReverseList(ListNode *  head)  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#123;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   //如果链表为空或者链表中只有一个元素  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   if(head==NULL || head-&amp;gt;m_pNext==NULL)  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;       return head;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   ListNode * p=head-&amp;gt;m_pNext;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   ListNode * q=head;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   while(p!=NULL)  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   &amp;#123;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;     q-&amp;gt;m_pNext=p-&amp;gt;m_pNext;//记录下p的下一个节点  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;     p-&amp;gt;m_pNext=head;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;     head=p;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;     p=q-&amp;gt;m_pNext;//准备将p的下一个节点放到表头  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   &amp;#125;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   return head;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;//递归方式  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;ListNode * ReverseList2(ListNode * head)  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#123;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    //如果链表为空或者链表中只有一个元素  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    if(head==NULL || head-&amp;gt;m_pNext==NULL)  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        return head;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    else  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#123;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;       ListNode * newhead=ReverseList2(head-&amp;gt;m_pNext);//先反转后面的链表  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;       head-&amp;gt;m_pNext-&amp;gt;m_pNext=head;//再将当前节点设置为其然来后面节点的后续节点  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;       head-&amp;gt;m_pNext=NULL;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;       return newhead;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;int _tmain(int argc, _TCHAR* argv[])  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#123;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    ListNode * Head=NULL;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    for(int i=0;i&amp;lt;10;i++)  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      CreateList(Head,i);  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    printList(Head);  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    Head=ReverseList(Head);  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    printList(Head);  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    system(&amp;quot;PAUSE&amp;quot;);  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    return 0;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;题目：定义一个函数，输入一个链表的头结点，反转该链表并输出反转后链表的头结点。&lt;/p&gt;
&lt;h3 id=&quot;1、非递归方式实现&quot;&gt;&lt;a href=&quot;#1、非递归方式实现&quot; class=&quot;headerlink&quot; title=&quot;1、非递归方式实现&quot;&gt;&lt;/a&gt;1、非递归方式实现&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;//思路为将节点从前到后依次放到表头，最后最后的节点到了最前面,最前面的节点到了最后面  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;ListNode * ReverseList(ListNode *  head)  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#123;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   //如果链表为空或者链表中只有一个元素  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   if(head==NULL || head-&amp;gt;m_pNext==NULL)  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;       return head;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   ListNode * p=head-&amp;gt;m_pNext;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   ListNode * q=head;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   while(p!=NULL)  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   &amp;#123;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;     q-&amp;gt;m_pNext=p-&amp;gt;m_pNext;//记录下p的下一个节点  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;     p-&amp;gt;m_pNext=head;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;     head=p;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;     p=q-&amp;gt;m_pNext;//准备将p的下一个节点放到表头  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   &amp;#125;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   return head;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
