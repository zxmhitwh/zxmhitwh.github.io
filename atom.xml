<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title> John&#39;s Blog</title>
  <subtitle>张晓明的博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2016-08-02T07:07:28.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>John</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>数据抽样问题(蓄水池抽样)</title>
    <link href="http://yoursite.com/2016/07/29/%E6%95%B0%E6%8D%AE%E6%8A%BD%E6%A0%B7%E9%97%AE%E9%A2%98(%E8%93%84%E6%B0%B4%E6%B1%A0%E6%8A%BD%E6%A0%B7)/"/>
    <id>http://yoursite.com/2016/07/29/数据抽样问题(蓄水池抽样)/</id>
    <published>2016-07-28T16:00:00.000Z</published>
    <updated>2016-08-02T07:07:28.000Z</updated>
    
    <content type="html">&lt;h1 id=&quot;海量数据中随机抽取一行&quot;&gt;&lt;a href=&quot;#海量数据中随机抽取一行&quot; class=&quot;headerlink&quot; title=&quot;海量数据中随机抽取一行&quot;&gt;&lt;/a&gt;海量数据中随机抽取一行&lt;/h1&gt;&lt;p&gt;题目：如何从n个对象（可以依次看到这n个对象，但事先不知道n的值）中随机选择一个？具体来说，如何在事先不知道文本行数的情况下读取该文件，从中随机抽取一行？&lt;br&gt;解析：该抽样叫蓄水池抽样。因为不可以事先知道n的大小，所以不能直接使用随机数。因为是随机抽样，所以每行被抽取的概率为1/n。我们以1的概率抽取第一行存储为s，以1/2的概率抽取第二行并替换s…以1/n的概率抽取第n行，并替换s。代码如下:&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;import sys&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;import random&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;def randomSampling():&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    s = &amp;apos;&amp;apos;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    i = 1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    for line in sys.stdin:&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        if i == 1:&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            s = line.strip()&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        else:&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            if (random.randint(1, i) == 1): # 以1/k的概率被抽取到&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                s = line.strip()&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        i = i + 1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    return s&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;if __name__ == &amp;apos;__main__&amp;apos;:&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    print randomSampling()&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h1 id=&quot;题目：从海量文本中抽取k行，使得每行被抽取的概率相等。&quot;&gt;&lt;a href=&quot;#题目：从海量文本中抽取k行，使得每行被抽取的概率相等。&quot; class=&quot;headerlink&quot; title=&quot;题目：从海量文本中抽取k行，使得每行被抽取的概率相等。&quot;&gt;&lt;/a&gt;题目：从海量文本中抽取k行，使得每行被抽取的概率相等。&lt;/h1&gt;&lt;p&gt;分析：使用蓄水池抽样，先抽取k行并保存到集合set中。以k/k＋1的概率抽取第k＋1行并替换掉set[0]，以k/k+2的概率抽取第k＋2行并替换掉第set[1]行。以k/k+m对概率抽取第k+m行，并替换掉set[(k+m)%k]行。每行依然是等概率选取.&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;import sys&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;import random&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;def randomSampling(k):&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    myset = []&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    i = 1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    for line in sys.stdin:&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        if i &amp;lt;= k:&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            myset.append(line.strip())&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        else:&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            if (random.randint(1, i) &amp;lt;= k):&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                myset[i % k] = line.strip()&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        i += 1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    return myset&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;if __name__ == &amp;apos;__main__&amp;apos;:&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    for line in randomSampling(3):&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        print line.strip()&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;海量数据中随机抽取一行&quot;&gt;&lt;a href=&quot;#海量数据中随机抽取一行&quot; class=&quot;headerlink&quot; title=&quot;海量数据中随机抽取一行&quot;&gt;&lt;/a&gt;海量数据中随机抽取一行&lt;/h1&gt;&lt;p&gt;题目：如何从n个对象（可以依次看到这n个对象，但事先不知道n的值）中随机选择一个？具体来说，如何在事先不知道文本行数的情况下读取该文件，从中随机抽取一行？&lt;br&gt;解析：该抽样叫蓄水池抽样。因为不可以事先知道n的大小，所以不能直接使用随机数。因为是随机抽样，所以每行被抽取的概率为1/n。我们以1的概率抽取第一行存储为s，以1/2的概率抽取第二行并替换s…以1/n的概率抽取第n行，并替换s。代码如下:&lt;br&gt;
    
    </summary>
    
      <category term="随机抽样算法" scheme="http://yoursite.com/categories/%E9%9A%8F%E6%9C%BA%E6%8A%BD%E6%A0%B7%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="蓄水池问题" scheme="http://yoursite.com/tags/%E8%93%84%E6%B0%B4%E6%B1%A0%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>利用word2vec作词聚类</title>
    <link href="http://yoursite.com/2016/07/25/%E5%88%A9%E7%94%A8word2vec%E4%BD%9C%E8%AF%8D%E8%81%9A%E7%B1%BB/"/>
    <id>http://yoursite.com/2016/07/25/利用word2vec作词聚类/</id>
    <published>2016-07-24T16:00:00.000Z</published>
    <updated>2016-07-28T09:40:54.000Z</updated>
    
    <content type="html">&lt;p&gt;前段时间做句子主干词识别，其中有一个特征是聚类编号，即对表达意向相近的词归为一个编号，这样对于一些未登录词来说该特征显得十分重要。这就用到了word2vec工具，也就是将词语向量化，然后根据欧几里得距离或者余弦距离并使用k-means聚类算法对词语聚类。下面介绍word2vec的使用方法。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;运行过程&quot;&gt;&lt;a href=&quot;#运行过程&quot; class=&quot;headerlink&quot; title=&quot;运行过程&quot;&gt;&lt;/a&gt;运行过程&lt;/h1&gt;&lt;p&gt;首先我们将google word2vec项目源码checkout 到本机，具体地址是&lt;a href=&quot;http://word2vec.googlecode.com/svn/trunk/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://word2vec.googlecode.com/svn/trunk/&lt;/a&gt;&lt;br&gt;进入目录，命令行输入make指令，进行编译。&lt;br&gt;这样我们就可以开始使用，word2vec工具了。&lt;br&gt;假定我语料名称为test.txt且在word2vec目录中。输入命令：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;./word2vec -train test.txt -output vectors.bin -cbow 0 -size 200 \&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;-window 5 -negative 0 -hs 1 -sample 1e-3 -threads 12 -binary 1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;以上命令表示的是输入文件是test.txt，输出文件是vectors.bin，不使用cbow模型，默认为Skip-Gram模型。 每个单词的向量维度是200，训练的窗口大小为5就是考虑一个词前五个和后五个词语（实际代码中还有一个随机选窗口的过程，窗口大小&amp;lt;=5）。不使用NEG方法，使用HS方法。-sampe指的是采样的阈值，如果一个词语在训练样本中出现的频率越大，那么就越会被采样。-binary为1指的是结果二进制存储，为0是普通存储（普通存储的时候是可以打开看到词语和对应的向量的）除了以上命令中的参数，word2vec还有几个参数对我们比较有用比如-alpha设置学习速率，默认的为0.025. –min-count设置最低频率，默认是5，如果一个词语在文档中出现的次数小于5，那么就会丢弃。-classes设置聚类个数，看了一下源码用的是k-means聚类的方法。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;前段时间做句子主干词识别，其中有一个特征是聚类编号，即对表达意向相近的词归为一个编号，这样对于一些未登录词来说该特征显得十分重要。这就用到了word2vec工具，也就是将词语向量化，然后根据欧几里得距离或者余弦距离并使用k-means聚类算法对词语聚类。下面介绍word2vec的使用方法。&lt;br&gt;
    
    </summary>
    
      <category term="深度学习" scheme="http://yoursite.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="聚类" scheme="http://yoursite.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E8%81%9A%E7%B1%BB/"/>
    
    
      <category term="word2vec" scheme="http://yoursite.com/tags/word2vec/"/>
    
  </entry>
  
  <entry>
    <title>依存句法分析</title>
    <link href="http://yoursite.com/2016/07/24/%E4%BE%9D%E5%AD%98%E5%8F%A5%E6%B3%95%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2016/07/24/依存句法分析/</id>
    <published>2016-07-23T16:00:00.000Z</published>
    <updated>2016-07-26T05:48:30.000Z</updated>
    
    <content type="html">&lt;p&gt;主要进行句子的依存分析，标注出句子中各词语之间的语法关系，如下图，如SBV主谓关系，VOB动宾关系，COO并列关系等，得到的依存关系可以用于其他多项NLP任务，如信息抽取、情感分析、自动问答、机器翻译等。&lt;br&gt;&lt;img src=&quot;images/jufafenxi.png&quot; alt=&quot;image&quot;&gt;&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;依存文法最早L.Tesniere在其著作《结构句法基础》（1959年）中提出，通过分析语言单位内成分之间的依存关系揭示其句法结构，主张句子中核心动词是支配其它成分的中心成分，而它本身却不受其它任何成分的支配，所有受支配成分都以某种依存关系从属于支配者。依存语法中关于依存关系有四条公理，在处理中文信息的研究中，中国学者提出了依存关系的第五条公理，如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个句子中只有一个成分是独立的；&lt;/li&gt;
&lt;li&gt;其它成分直接依存于某一成分；&lt;/li&gt;
&lt;li&gt;任何一个成分都不能依存与两个或两个以上的成分；&lt;/li&gt;
&lt;li&gt;如果A成分直接依存于B成分，而C成分在句中位于A和B之间，那么C或者直接依存于B，或者直接依存于A和B之间的某一成分；&lt;/li&gt;
&lt;li&gt;中心成分左右两面的其它成分相互不发生关系。&lt;br&gt;句子成分间相互支配与被支配、依存与被依存的现象普遍存在于汉语的词汇（合成语）、短语、单句、复合直到句群的各级能够独立运用的语言单位之中，这一特点为依存关系的普遍性，依存句法分析可以反映出句子各成分之间的语义修饰关系，它可以获得长距离的搭配信息，并与句子成分的物理位置无关。&lt;h1 id=&quot;算法&quot;&gt;&lt;a href=&quot;#算法&quot; class=&quot;headerlink&quot; title=&quot;算法&quot;&gt;&lt;/a&gt;算法&lt;/h1&gt;当前一种主流的思路是Transition-based的依存分析，定义一个栈结构，以及一些动作，这些动作分别是句子中元素的入栈和出栈（出栈动作包括出栈元素与栈顶元素的依存边），然后训练一个分类器，对于特定状态，预测合适动作。&lt;br&gt;动作包括：&lt;/li&gt;
&lt;li&gt;SHIFT，从原句子中取一个词入栈&lt;/li&gt;
&lt;li&gt;LEFT-ARC(R)，栈顶第二个元素出栈，出站后，出栈元素为子节点，栈顶元素为父节点，边类型为R&lt;/li&gt;
&lt;li&gt;RIGHT-ARC(R)，栈顶第一个元素出栈，出站后，出栈元素为子节点，栈顶元素为父节点，边类型为R&lt;br&gt;&lt;img src=&quot;images/image2.png&quot; alt=&quot;ima&quot;&gt;&lt;br&gt;&lt;a href=&quot;1.pdf&quot;&gt;论文&lt;/a&gt;&lt;br&gt;当前大部分研究集中在动作选择时候的分类器设计和特征选择上。&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;主要进行句子的依存分析，标注出句子中各词语之间的语法关系，如下图，如SBV主谓关系，VOB动宾关系，COO并列关系等，得到的依存关系可以用于其他多项NLP任务，如信息抽取、情感分析、自动问答、机器翻译等。&lt;br&gt;&lt;img src=&quot;images/jufafenxi.png&quot; alt=&quot;image&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="句法分析" scheme="http://yoursite.com/categories/%E5%8F%A5%E6%B3%95%E5%88%86%E6%9E%90/"/>
    
    
      <category term="句法树" scheme="http://yoursite.com/tags/%E5%8F%A5%E6%B3%95%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>使用CRF++用于中文命名实体识别</title>
    <link href="http://yoursite.com/2016/07/22/%E4%BD%BF%E7%94%A8CRF++%E7%94%A8%E4%BA%8E%E4%B8%AD%E6%96%87%E5%91%BD%E5%90%8D%E5%AE%9E%E4%BD%93%E8%AF%86%E5%88%AB/"/>
    <id>http://yoursite.com/2016/07/22/使用CRF++用于中文命名实体识别/</id>
    <published>2016-07-21T16:00:00.000Z</published>
    <updated>2016-07-25T08:00:53.000Z</updated>
    
    <content type="html">&lt;h1 id=&quot;1-语料格式&quot;&gt;&lt;a href=&quot;#1-语料格式&quot; class=&quot;headerlink&quot; title=&quot;1.语料格式&quot;&gt;&lt;/a&gt;1.语料格式&lt;/h1&gt;&lt;p&gt;CRF++ 可以用于分词、词性标注和命名实体识别等任务。&lt;br&gt;官方文档: &lt;a href=&quot;https://taku910.github.io/crfpp/&quot; title=&quot;CRF++&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;/a&gt;&lt;br&gt;我们使用msra 2007用于命名实体识别的训练集和测试集，分为3个类别：人名(PER)、地名(LOC)、机构名(ORG),采用标准的BIEO方式处理，格式如下：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;是	O&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;根	O&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;据	O&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;宋	B-PER&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;神	I-PER&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;宗	E-PER&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;时	O&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;，	O&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;官	O&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;拜	O&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;礼	B-ORG&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;部	E-ORG&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;郎	O&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;杨	B-PER&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;次	I-PER&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;公	E-PER&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;的	O&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;“	O&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;牧	O&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;牛	O&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;颂	O&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;”	O&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;2-模板构建&quot;&gt;&lt;a href=&quot;#2-模板构建&quot; class=&quot;headerlink&quot; title=&quot;2.模板构建&quot;&gt;&lt;/a&gt;2.模板构建&lt;/h1&gt;&lt;p&gt;例如，对于模板:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;# Unigram&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;U00:%x[-2,0]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;U01:%x[-1,0]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;U02:%x[0,0]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;U03:%x[1,0]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;U04:%x[2,0]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;U05:%x[-2,0]/%x[-1,0]/%x[0,0]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;U06:%x[-1,0]/%x[0,0]/%x[1,0]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;U07:%x[0,0]/%x[1,0]/%x[2,0]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;U08:%x[-1,0]/%x[0,0]                                          &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;U09:%x[0,0]/%x[1,0]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;# Bigram&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;B&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;在特征模板文件中，每一行(如U00:%x[-2,0]）代表一个特征，而宏“%x[行位置,列位置]”则代表了相对于当前指向的token的行偏移和列的绝对位置.&lt;br&gt;CRF++里将特征分成两种类型，一种是Unigram的，“U”起头，另外一种是Bigram的，“B”起头。对于Unigram的特征，假如一个特征模板是”U01:%x[-1,0]“, CRF++会自动的生成一组特征函数(func1 … funcN) 集合:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;func1 = if (output = B and feature=&amp;quot;U01&amp;quot;) return 1 else return 0&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;func2 = if (output = I and feature=&amp;quot;U01&amp;quot;) return 1 else return 0&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;func3 = if (output = E and feature=&amp;quot;U01&amp;quot;) return 1 else return 0&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;....&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;生成的特征函数的数目 = (L * N)，其中L是输出的类型的个数，这里是B,I,E这几个tag，N是通过模板扩展出来的所有单个字符串(特征）的个数。&lt;br&gt;而Bigram特征主要是当前的token和前面一个位置token的自动组合生成的bigram特征集合。最后需要注意的是U01和U02这些标志位，与特征token组合到一起主要是区分“U01:問”和“U02:問”这类特征，虽然抽取的”字”特征是一样的，但是在CRF++中这是有区别的特征。&lt;/p&gt;
&lt;h1 id=&quot;3-执行命令&quot;&gt;&lt;a href=&quot;#3-执行命令&quot; class=&quot;headerlink&quot; title=&quot;3.执行命令&quot;&gt;&lt;/a&gt;3.执行命令&lt;/h1&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;../../crf_learn -f 3 -c 4.0 template train.data model  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;../../crf_test -m model test.data  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;../../crf_learn -a MIRA -f 3 template train.data model  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;../../crf_test -m model test.data&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h1 id=&quot;4-执行结果&quot;&gt;&lt;a href=&quot;#4-执行结果&quot; class=&quot;headerlink&quot; title=&quot;4.执行结果&quot;&gt;&lt;/a&gt;4.执行结果&lt;/h1&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;23&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;24&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;CRF++: Yet Another CRF Tool Kit&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;Copyright(C) 2005 Taku Kudo, All rights reserved.&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;reading training data: 100.. 200.. 300.. 400.. 500.. 600.. 700.. 800.. &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;Done! 1.94 s&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;Number of sentences: 823&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;Number of features:  1075862&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;Number of thread(s): 1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;Freq:                1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;eta:                 0.00010&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;C:                   1.00000&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;shrinking size:      20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;Algorithm:           CRF&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;iter=0 terr=0.99103 serr=1.00000 obj=54318.36623 diff=1.00000&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;iter=1 terr=0.35260 serr=0.98177 obj=44996.53537 diff=0.17161&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;iter=2 terr=0.35260 serr=0.98177 obj=21032.70195 diff=0.53257&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;iter=3 terr=0.23879 serr=0.94532 obj=13642.32067 diff=0.35138&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;iter=4 terr=0.15324 serr=0.88700 obj=8985.70071 diff=0.34134&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;iter=5 terr=0.11605 serr=0.80680 obj=7118.89846 diff=0.20775&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;iter=6 terr=0.09305 serr=0.72175 obj=5531.31015 diff=0.22301&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;iter=7 terr=0.08132 serr=0.68408 obj=4618.24644 diff=0.16507&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;iter=8 terr=0.06228 serr=0.59174 obj=3742.93171 diff=0.18953&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;其中：&lt;br&gt;iter: 迭代的次数&lt;br&gt;terr: 预测的标注错误率&lt;br&gt;serr: 预测的句子标注错误率&lt;br&gt;obj: 当前目标值，当达到一定值时，迭代停止&lt;br&gt;diff: 与上一次obj的相对diff&lt;br&gt;有4个可调的参数来控制训练过程:&lt;br&gt;-a CRF-L2 or CRF-L1:正则化项设置&lt;br&gt;-c float: 用于平衡过拟合和欠拟合&lt;br&gt;-f NUM: 用于控制迭代的次数，不少于NUM次&lt;br&gt;-p NUM: 用于控制线程的个数&lt;br&gt;CRF++ 支持single-best MIRA training&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;crf_test -v1 -m model test.data| head&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;-v1: 显示预测的目标概率&lt;br&gt;-v2: 显示所有的预测概率&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-语料格式&quot;&gt;&lt;a href=&quot;#1-语料格式&quot; class=&quot;headerlink&quot; title=&quot;1.语料格式&quot;&gt;&lt;/a&gt;1.语料格式&lt;/h1&gt;&lt;p&gt;CRF++ 可以用于分词、词性标注和命名实体识别等任务。&lt;br&gt;官方文档: &lt;a href=&quot;https://taku910.github.io/crfpp/&quot; title=&quot;CRF++&quot;&gt;&lt;/a&gt;&lt;br&gt;我们使用msra 2007用于命名实体识别的训练集和测试集，分为3个类别：人名(PER)、地名(LOC)、机构名(ORG),采用标准的BIEO方式处理，格式如下：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;是	O&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;根	O&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;据	O&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;宋	B-PER&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;神	I-PER&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;宗	E-PER&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;时	O&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;，	O&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;官	O&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;拜	O&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;礼	B-ORG&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;部	E-ORG&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;郎	O&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;杨	B-PER&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;次	I-PER&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;公	E-PER&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;的	O&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;“	O&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;牧	O&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;牛	O&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;颂	O&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;”	O&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="命名实体识别" scheme="http://yoursite.com/categories/%E5%91%BD%E5%90%8D%E5%AE%9E%E4%BD%93%E8%AF%86%E5%88%AB/"/>
    
    
      <category term="CRF" scheme="http://yoursite.com/tags/CRF/"/>
    
  </entry>
  
  <entry>
    <title>通用命名实体识别方法及步骤</title>
    <link href="http://yoursite.com/2016/07/15/%E9%80%9A%E7%94%A8%E5%91%BD%E5%90%8D%E5%AE%9E%E4%BD%93%E8%AF%86%E5%88%AB%E6%96%B9%E6%B3%95%E5%8F%8A%E6%AD%A5%E9%AA%A4/"/>
    <id>http://yoursite.com/2016/07/15/通用命名实体识别方法及步骤/</id>
    <published>2016-07-14T16:00:00.000Z</published>
    <updated>2016-07-18T02:43:27.000Z</updated>
    
    <content type="html">&lt;h1 id=&quot;一、项目简介：&quot;&gt;&lt;a href=&quot;#一、项目简介：&quot; class=&quot;headerlink&quot; title=&quot;一、项目简介：&quot;&gt;&lt;/a&gt;一、项目简介：&lt;/h1&gt;&lt;p&gt;实体识别是nlp领域的基础工作，但是，目前了解到实体识别相关的项目主要都是基于词表来实现的。虽然词表的准确率很高，但是，词表的挖掘和维护的工作量也将很大，基于词表主要问题：1，词表覆盖率不全，需要不断的更新挖掘新词来补充词表；2，词表数目过大，随着业务的不断发展，挖掘的新词需要不断的扩充到词表中，词表会越来越大；3，词表的增大也伴随着维护的困难。所以，本项目的主要目的是从纯模型的角度来解决以上问题。传统的实体识别项目主要解决的是人名，地名，机构名，这三大实体类别。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;二、主要步骤：&quot;&gt;&lt;a href=&quot;#二、主要步骤：&quot; class=&quot;headerlink&quot; title=&quot;二、主要步骤：&quot;&gt;&lt;/a&gt;二、主要步骤：&lt;/h1&gt;&lt;p&gt;首先，使用分词系统对文本进行分词，根据各自的任务不同选择是否需要词性特征。考虑本文处理的是短文本query，基本上都是一个或几个实体词，做为query。词性在这个场景下效果不是特别明显，所以，没有采用词性特征。由于使用CRF模型学习与预测，特征计算出来为连续型变量，因此，对结果进行离散化处理，分析各个特征的分布，对特征离散化结果再进一步合并处理。实体识别任务等同于实体边界识别，所以在边界特征的选取上对最终效果会有非常明显的影响。主要提供了一些通用的边界特征和紧密度特征的提取程序。 &lt;/p&gt;
&lt;h2 id=&quot;1-特征提取&quot;&gt;&lt;a href=&quot;#1-特征提取&quot; class=&quot;headerlink&quot; title=&quot;1.特征提取&quot;&gt;&lt;/a&gt;1.特征提取&lt;/h2&gt;&lt;p&gt;左熵：表示的是当前词，左边搭配的词数量的多少。左熵的值越大，表示这个词越有可能是右边界（实体的后缀词），与左边的词可能构成实体。&lt;br&gt;右熵：表示的是当前词，右边搭配词的数量的多少。右熵的值越大，表示这个词越有可能是左边界（实体前缀，或者，单独的实体），与右边的词可能构成实体。&lt;br&gt;点互信息：表示的是两个词的紧密度，本文特征提取的是当前词与前一个词的互信息。值越大，表示两个词越紧密，可能是一个实体词或实体词的一部分。等于零，表示两个词相互独立。值越小，表示两个词互斥出现。因为，考虑到最终互信息词表过大，所以，把小于一定阈值的互信息删除，只考虑紧密度比较大的词。&lt;br&gt;还有其他类型的特征比如，词长度，词性等特征。还有自定义的特征：实体词的前缀特征，实体词的后缀特征。可以根据需要识别的类型，从已收集的词表或者再使用一些挖掘词表的方法。从中提取后缀词，后缀字，前缀词，前缀字特征以用来辅助确定实体的边界信息。&lt;br&gt;组合特征：经测试特征模板中添加一部分组合特征对效果提升比较明显。比如增加：1，当前词的右熵与下一个词的左熵。2，当前词的后缀词特征之间的组合。其他可根据自己的应用测试不同的组合情况。&lt;/p&gt;
&lt;h2 id=&quot;2-语料标注&quot;&gt;&lt;a href=&quot;#2-语料标注&quot; class=&quot;headerlink&quot; title=&quot;2.语料标注&quot;&gt;&lt;/a&gt;2.语料标注&lt;/h2&gt;&lt;p&gt; 模型训练阶段使用提取特征框架，将主动学习中已经标记好的语料转换为CRF需要的格式。本文采用BIO标记识别的位置信息。B表示实体开始的词，I表示实体中间的词。O表示非实体词。当标记语料比较多的时候，还可以使用BIEO或BIESO这种方式来标记实体。E表示实体结束词，S表示当前词是一个实体，可以提供更为丰富的边界特征，提高边界识别的准确率。本文标记语料只有5000条数据，测试了BIEO或BIESO的方式，数据稀疏比较严重，所以还是使用BIO作为标记语料。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一、项目简介：&quot;&gt;&lt;a href=&quot;#一、项目简介：&quot; class=&quot;headerlink&quot; title=&quot;一、项目简介：&quot;&gt;&lt;/a&gt;一、项目简介：&lt;/h1&gt;&lt;p&gt;实体识别是nlp领域的基础工作，但是，目前了解到实体识别相关的项目主要都是基于词表来实现的。虽然词表的准确率很高，但是，词表的挖掘和维护的工作量也将很大，基于词表主要问题：1，词表覆盖率不全，需要不断的更新挖掘新词来补充词表；2，词表数目过大，随着业务的不断发展，挖掘的新词需要不断的扩充到词表中，词表会越来越大；3，词表的增大也伴随着维护的困难。所以，本项目的主要目的是从纯模型的角度来解决以上问题。传统的实体识别项目主要解决的是人名，地名，机构名，这三大实体类别。&lt;br&gt;
    
    </summary>
    
      <category term="命名实体识别" scheme="http://yoursite.com/categories/%E5%91%BD%E5%90%8D%E5%AE%9E%E4%BD%93%E8%AF%86%E5%88%AB/"/>
    
    
      <category term="NER" scheme="http://yoursite.com/tags/NER/"/>
    
  </entry>
  
  <entry>
    <title>通俗理解卷积神经网络(CNN)[转载]</title>
    <link href="http://yoursite.com/2016/07/11/%E9%80%9A%E4%BF%97%E7%90%86%E8%A7%A3%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C(CNN)/"/>
    <id>http://yoursite.com/2016/07/11/通俗理解卷积神经网络(CNN)/</id>
    <published>2016-07-10T16:00:00.000Z</published>
    <updated>2016-07-14T07:30:56.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;1-人工神经网络&quot;&gt;&lt;a href=&quot;#1-人工神经网络&quot; class=&quot;headerlink&quot; title=&quot;1.人工神经网络&quot;&gt;&lt;/a&gt;1.人工神经网络&lt;/h2&gt;&lt;h3 id=&quot;1-1神经元&quot;&gt;&lt;a href=&quot;#1-1神经元&quot; class=&quot;headerlink&quot; title=&quot;1.1神经元&quot;&gt;&lt;/a&gt;1.1神经元&lt;/h3&gt;&lt;p&gt;神经网络由大量的神经元相互连接而成。每个神经元接受线性组合的输入后，最开始只是简单的线性加权，后来给每个神经元加上了非线性的激活函数，从而进行非线性变换后输出。每两个神经元之间的连接代表加权值，称之为权重（weight）。不同的权重和激活函数，则会导致神经网络不同的输出。&lt;/p&gt;
&lt;p&gt;举个手写识别的例子，给定一个未知数字，让神经网络识别是什么数字。此时的神经网络的输入由一组被输入图像的像素所激活的输入神经元所定义。在通过非线性激活函数进行非线性变换后，神经元被激活然后被传递到其他神经元。重复这一过程，直到最后一个输出神经元被激活。从而识别当前数字是什么字。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;br&gt;    神经网络的每个神经元如下&lt;br&gt;    &lt;img src=&quot;http://img.blog.csdn.net/20160703112618929&quot; alt=&quot;神经网络示例&quot;&gt;&lt;br&gt;类似wx + b的形式，其中&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;a1~an为输入向量，当然，也常用x1~xn表示输入&lt;/li&gt;
&lt;li&gt;w1~wn为权重&lt;/li&gt;
&lt;li&gt;b为偏置bias&lt;/li&gt;
&lt;li&gt;f 为激活函数&lt;/li&gt;
&lt;li&gt;&lt;p&gt;t 为输出&lt;br&gt;  如果只是上面这样一说，估计以前没接触过的十有八九又必定迷糊了。事实上，上述简单模型可以追溯到20世纪50/60年代的感知器，可以把感知器理解为一个根据不同因素、以及各个因素的重要性程度而做决策的模型。&lt;/p&gt;
&lt;p&gt;  举个例子，这周末北京有一草莓音乐节，那去不去呢？决定你是否去有3个因素，这三个因素可以对应三个输入，分别用x1、x2、x3表示。此外，这三个因素对做决策的影响程度不一样，各自的影响程度用权重w1、w2、w3表示。一般来说，音乐节的演唱嘉宾会非常影响你去不去，唱得好的前提下 即便天气不好、没人陪同都可忍受，但如果唱得不好还不如你上台唱呢。所以，我们可以如下表示：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;x1：是否有喜欢的演唱嘉宾。x1 = 1 你喜欢这些嘉宾，x1 = 0 你不喜欢这些嘉宾。嘉宾因素的权重w1 = 5&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;x2：天气好坏。x2 = 1 天气好，x2 = 0 天气不好。天气权重w2 = 2。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;x3：是否有人陪你同去。x3 = 1 有人陪你同去，x2 = 0 没人陪你同去。是否有陪同的权重w3 = 3。&lt;br&gt;  这样，咱们的决策模型函数便建立起来了：f(x) = g( w1&lt;em&gt;x1 + w2&lt;/em&gt;x2 + w3*x3 + b )，g表示激活函数。然后设定一个阈值，如果这些加权输入值的和[ 即f(x) ]超过这个阈值，就输出1：代表去参加音乐节，否则输出0：代表不去参加音乐节。&lt;br&gt;  一开始，激活函数是线性函数，导致所有的变换都是线性变换，比如if x &amp;lt; 0 f(x) = 0; if x &amp;gt; 0,f(x) = 1，输出都是输入的线性变换。后来实际应用中发现，线性激活函数太过局限，于是人们引入了非线性激活函数。&lt;/p&gt;
&lt;h3 id=&quot;1-2神经网络&quot;&gt;&lt;a href=&quot;#1-2神经网络&quot; class=&quot;headerlink&quot; title=&quot;1.2神经网络&quot;&gt;&lt;/a&gt;1.2神经网络&lt;/h3&gt;&lt;p&gt;将下图的这种单个神经元&lt;br&gt;&lt;img src=&quot;http://img.blog.csdn.net/20160703140734967&quot; alt=&quot;神经网络示例&quot;&gt;&lt;br&gt;组织在一起，便形成了神经网络。下图便是一个三层神经网络结构&lt;br&gt;&lt;img src=&quot;http://img.blog.csdn.net/20160703140745657&quot; alt=&quot;神经网络示例&quot;&gt;&lt;br&gt;上图中最左边的原始输入信息称之为输入层，最右边的神经元称之为输出层（上图中输出层只有一个神经元），中间的叫隐藏层。&lt;/p&gt;
&lt;p&gt;  啥叫输入层、输出层、隐藏层呢？&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;输入层（Input layer），众多神经元（Neuron）接受大量非线形输入讯息。输入的讯息称为输入向量。&lt;br&gt;输出层（Output layer），讯息在神经元链接中传输、分析、权衡，形成输出结果。输出的讯息称为输出向量。&lt;br&gt;隐藏层（Hidden layer），简称“隐层”，是输入层和输出层之间众多神经元和链接组成的各个层面。如果有多个隐藏层，则意味着多个激活函数。&lt;br&gt;    同时，每一层都可能由单个或多个神经元组成，每一层的输出将会作为下一层的输入数据。比如下图中间隐藏层来说，隐藏层的3个神经元a1、a2、a3皆各自接受来自多个不同权重的输入，接着，a1、a2、a3又在自身各自不同权重的影响下 成为的输出层的输入，最终由输出层输出最终结果。&lt;br&gt; &lt;img src=&quot;http://img.blog.csdn.net/20160703110336151&quot; alt=&quot;神经网络示例&quot;&gt;&lt;br&gt;  &lt;img src=&quot;http://img.blog.csdn.net/20160703113851013&quot; alt=&quot;神经网络示例&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;2-CNN之卷积计算层&quot;&gt;&lt;a href=&quot;#2-CNN之卷积计算层&quot; class=&quot;headerlink&quot; title=&quot;2.CNN之卷积计算层&quot;&gt;&lt;/a&gt;2.CNN之卷积计算层&lt;/h2&gt;&lt;h3 id=&quot;2-1什么是卷积&quot;&gt;&lt;a href=&quot;#2-1什么是卷积&quot; class=&quot;headerlink&quot; title=&quot;2.1什么是卷积&quot;&gt;&lt;/a&gt;2.1什么是卷积&lt;/h3&gt;&lt;p&gt; 首先，我们来了解下什么是卷积操作。&lt;br&gt;    对图像（不同的数据窗口数据）和滤波矩阵（一组固定的权重：因为每个神经元的权重固定，所以又可以看做一个恒定的滤波器filter）做内积（逐个元素相乘再求和）的操作就是所谓的『卷积』操作，也是卷积神经网络的名字来源。&lt;br&gt;    比如下图中，图中左边部分是原始输入数据，图中中间部分是滤波器filter，图中右边是输出的新的二维数据。&lt;br&gt; &lt;img src=&quot;http://img.blog.csdn.net/20160702215705128&quot; alt=&quot;神经网络示例&quot;&gt;&lt;br&gt;中间滤波器filter与数据窗口做内积，其具体计算过程则是：4&lt;em&gt;0 + 0&lt;/em&gt;0 + 0&lt;em&gt;0 + 0&lt;/em&gt;0 + 0&lt;em&gt;1 + 0&lt;/em&gt;1 + 0&lt;em&gt;0 + 0&lt;/em&gt;1 + -4*2 = -8&lt;/p&gt;
&lt;h3 id=&quot;2-2动态卷积图&quot;&gt;&lt;a href=&quot;#2-2动态卷积图&quot; class=&quot;headerlink&quot; title=&quot;2.2动态卷积图&quot;&gt;&lt;/a&gt;2.2动态卷积图&lt;/h3&gt;&lt;p&gt;在CNN中，滤波器filter对局部输入数据进行卷积计算。每计算完一个数据窗口内的局部数据后，数据窗口不断平移滑动，直到计算完所有数据。这个过程中，有这么几个参数：&lt;br&gt;　　a. 深度depth：神经元个数，决定输出的depth厚度。&lt;br&gt;　　b. 步长stride：决定滑动多少步可以到边缘&lt;br&gt;　　c. 填充值zero-padding：在外围边缘补充若干圈0，方便从初始位置以步长为单位可以刚好滑倒末尾位置，通俗地讲就是为了总长能被步长整除。&lt;br&gt;&lt;img src=&quot;http://img.blog.csdn.net/20160707204048899&quot; alt=&quot;神经网络示例&quot;&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-人工神经网络&quot;&gt;&lt;a href=&quot;#1-人工神经网络&quot; class=&quot;headerlink&quot; title=&quot;1.人工神经网络&quot;&gt;&lt;/a&gt;1.人工神经网络&lt;/h2&gt;&lt;h3 id=&quot;1-1神经元&quot;&gt;&lt;a href=&quot;#1-1神经元&quot; class=&quot;headerlink&quot; title=&quot;1.1神经元&quot;&gt;&lt;/a&gt;1.1神经元&lt;/h3&gt;&lt;p&gt;神经网络由大量的神经元相互连接而成。每个神经元接受线性组合的输入后，最开始只是简单的线性加权，后来给每个神经元加上了非线性的激活函数，从而进行非线性变换后输出。每两个神经元之间的连接代表加权值，称之为权重（weight）。不同的权重和激活函数，则会导致神经网络不同的输出。&lt;/p&gt;
&lt;p&gt;举个手写识别的例子，给定一个未知数字，让神经网络识别是什么数字。此时的神经网络的输入由一组被输入图像的像素所激活的输入神经元所定义。在通过非线性激活函数进行非线性变换后，神经元被激活然后被传递到其他神经元。重复这一过程，直到最后一个输出神经元被激活。从而识别当前数字是什么字。&lt;br&gt;
    
    </summary>
    
      <category term="Deep Learning" scheme="http://yoursite.com/categories/Deep-Learning/"/>
    
    
      <category term="Deep Learning" scheme="http://yoursite.com/tags/Deep-Learning/"/>
    
  </entry>
  
  <entry>
    <title>C/C++中计算程序运行时间的方法</title>
    <link href="http://yoursite.com/2016/07/09/C:C++%E4%B8%AD%E8%AE%A1%E7%AE%97%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E6%97%B6%E9%97%B4%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2016/07/09/C:C++中计算程序运行时间的方法/</id>
    <published>2016-07-08T16:00:00.000Z</published>
    <updated>2016-07-14T07:07:00.000Z</updated>
    
    <content type="html">&lt;p&gt;最近写完程序在公司需要测试每个句子输入到返回结果的运行时间，刚开始使用clock()函数是精确到毫秒，但是经过测试然并卵，总是返回0ms，程序运行时间太短，最后总结一下：&lt;/p&gt;
&lt;h3 id=&quot;精确到毫秒ms&quot;&gt;&lt;a href=&quot;#精确到毫秒ms&quot; class=&quot;headerlink&quot; title=&quot;精确到毫秒ms&quot;&gt;&lt;/a&gt;精确到毫秒ms&lt;/h3&gt;&lt;p&gt;clock()计算的是CPU执行耗时，注意是CPU！如果有多个核并行，最后的结果是每个CPU上运算时间的总和！想要精确到毫秒，可以double(end -begin)*1000/CLOCKS_PER_SEC&lt;br&gt;一般来说，只要求精确到秒的话，time是很好使的&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;#include &amp;lt;&amp;lt;/span&amp;gt;stdio.h&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;#include &amp;lt;&amp;lt;/span&amp;gt;time.h&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;int main()&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    time_t t_start, t_end;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    t_start = time(NULL) ;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    sleep(3000);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    t_end = time(NULL) ;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    printf(&amp;quot;time: %.0f s\n&amp;quot;, difftime(t_end,t_start)) ;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    return 0;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;精确到微秒us&quot;&gt;&lt;a href=&quot;#精确到微秒us&quot; class=&quot;headerlink&quot; title=&quot;精确到微秒us&quot;&gt;&lt;/a&gt;精确到微秒us&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;#include &amp;lt;&amp;lt;/span&amp;gt;stdio.h&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;#include &amp;lt;&amp;lt;/span&amp;gt;sys/time.h&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;int main() &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    struct timeval start, end;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    gettimeofday( &amp;amp;start, NULL );&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    sleep(3);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    gettimeofday( &amp;amp;end, NULL );&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    int timeuse = 1000000 * ( end.tv_sec - start.tv_sec ) + end.tv_usec -start.tv_usec;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    printf(&amp;quot;time: %d us\n&amp;quot;, timeuse);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    return 0;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;最近写完程序在公司需要测试每个句子输入到返回结果的运行时间，刚开始使用clock()函数是精确到毫秒，但是经过测试然并卵，总是返回0ms，程序运行时间太短，最后总结一下：&lt;/p&gt;
&lt;h3 id=&quot;精确到毫秒ms&quot;&gt;&lt;a href=&quot;#精确到毫秒ms&quot; class=&quot;headerlink&quot; title=&quot;精确到毫秒ms&quot;&gt;&lt;/a&gt;精确到毫秒ms&lt;/h3&gt;&lt;p&gt;clock()计算的是CPU执行耗时，注意是CPU！如果有多个核并行，最后的结果是每个CPU上运算时间的总和！想要精确到毫秒，可以double(end -begin)*1000/CLOCKS_PER_SEC&lt;br&gt;一般来说，只要求精确到秒的话，time是很好使的&lt;br&gt;
    
    </summary>
    
      <category term="C/C++" scheme="http://yoursite.com/categories/C-C/"/>
    
    
      <category term="-C/C++ -运行时间" scheme="http://yoursite.com/tags/C-C-%E8%BF%90%E8%A1%8C%E6%97%B6%E9%97%B4/"/>
    
  </entry>
  
  <entry>
    <title>利用标注语料生成决策weights</title>
    <link href="http://yoursite.com/2016/07/05/%E5%88%A9%E7%94%A8%E6%A0%87%E6%B3%A8%E8%AF%AD%E6%96%99%E7%94%9F%E6%88%90%E5%86%B3%E7%AD%96weights/"/>
    <id>http://yoursite.com/2016/07/05/利用标注语料生成决策weights/</id>
    <published>2016-07-04T16:00:00.000Z</published>
    <updated>2016-07-08T09:18:09.000Z</updated>
    
    <content type="html">&lt;p&gt;1、之前两周利用主动学习的方式训练集&lt;br&gt;2、标注数据分离一小部分作为测试集利用LR分类器调参。&lt;br&gt;3、利用最有参数训练标注语料生成特征权重weights。&lt;br&gt;3、使用weights获得主干提取demo。&lt;br&gt;周一的时候做好了主干提取的Demo初始版本，经过测试效果不太理想&lt;br&gt;分析原因：训练集过少、覆盖面过窄、稳定性不高&lt;br&gt;这周的主要工作：&lt;br&gt;1、提取多种语料库中的资源做人工语料标注&lt;br&gt;2、增加部分特征，扩大特征维度&lt;br&gt;3、特征结构统一化，例如某个词的特征用词典表示，预定义好所有的key。暂时定义如下：&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;列表内容&lt;/li&gt;
&lt;li&gt;word_0  当前词本身&lt;/li&gt;
&lt;li&gt;pos_0  当前词本身词性&lt;/li&gt;
&lt;li&gt;cluster_0 当前词本身聚类编号&lt;/li&gt;
&lt;li&gt;word_-1  当前词的前一个词本身&lt;/li&gt;
&lt;li&gt;pos_-1   当前词的前一个词词性&lt;/li&gt;
&lt;li&gt;cluster_-1   当前词的前一个词聚类编号&lt;/li&gt;
&lt;li&gt;word_1   当前词的后一个词本身&lt;/li&gt;
&lt;li&gt;pos_1    当前词的后一个词词性&lt;/li&gt;
&lt;li&gt;cluster_1   当前词的后一个词聚类编号&lt;/li&gt;
&lt;li&gt;parent_edge_0   当前词的父边关系类型&lt;/li&gt;
&lt;li&gt;child_edge_0   当前词的子边关系类型&lt;/li&gt;
&lt;li&gt;word_parent_node_0   当前词的父节点词本身&lt;/li&gt;
&lt;li&gt;pos_parent_node_0  当前词的父节点词性&lt;/li&gt;
&lt;li&gt;cluster_parent_node_0 当前词的父节点词聚类编号&lt;/li&gt;
&lt;li&gt;word_parent&lt;em&gt;node&lt;/em&gt;-1   当前词的前一个词的父节点词本身&lt;/li&gt;
&lt;li&gt;pos_parent&lt;em&gt;node&lt;/em&gt;-1  当前词的前一个词的父节点词性&lt;/li&gt;
&lt;li&gt;cluster_parent&lt;em&gt;node&lt;/em&gt;-1 当前词的前一个词的父节点词聚类编号&lt;/li&gt;
&lt;li&gt;word_parent_node_1   当前词的后一个词的父节点词本身&lt;/li&gt;
&lt;li&gt;pos_parent_node_1  当前词的后一个词的父节点词性&lt;/li&gt;
&lt;li&gt;cluster_parent_node_1 当前词的后一个词的父节点词聚类编号&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;计划下周：&lt;br&gt;把句子主干提取完善版本完成。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;1、之前两周利用主动学习的方式训练集&lt;br&gt;2、标注数据分离一小部分作为测试集利用LR分类器调参。&lt;br&gt;3、利用最有参数训练标注语料生成特征权重weights。&lt;br&gt;3、使用weights获得主干提取demo。&lt;br&gt;周一的时候做好了主干提取的Demo初始版本，经过测试效果不太理想&lt;br&gt;分析原因：训练集过少、覆盖面过窄、稳定性不高&lt;br&gt;这周的主要工作：&lt;br&gt;1、提取多种语料库中的资源做人工语料标注&lt;br&gt;2、增加部分特征，扩大特征维度&lt;br&gt;3、特征结构统一化，例如某个词的特征用词典表示，预定义好所有的key。暂时定义如下：&lt;/p&gt;
    
    </summary>
    
      <category term="句子主干提取" scheme="http://yoursite.com/categories/%E5%8F%A5%E5%AD%90%E4%B8%BB%E5%B9%B2%E6%8F%90%E5%8F%96/"/>
    
    
      <category term="逻辑回归" scheme="http://yoursite.com/tags/%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/"/>
    
      <category term="主动学习" scheme="http://yoursite.com/tags/%E4%B8%BB%E5%8A%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>通过主动学习的方法进行自动语料标注</title>
    <link href="http://yoursite.com/2016/06/24/%E9%80%9A%E8%BF%87%E4%B8%BB%E5%8A%A8%E5%AD%A6%E4%B9%A0%E7%9A%84%E6%96%B9%E6%B3%95%E8%BF%9B%E8%A1%8C%E8%87%AA%E5%8A%A8%E8%AF%AD%E6%96%99%E6%A0%87%E6%B3%A8/"/>
    <id>http://yoursite.com/2016/06/24/通过主动学习的方法进行自动语料标注/</id>
    <published>2016-06-23T16:00:00.000Z</published>
    <updated>2016-07-08T10:50:19.000Z</updated>
    
    <content type="html">&lt;p&gt;   目前正在做句子主干提取方面的工作，主要方法是构建二分类器，提取句子分词之后每个词的特征来决定分词的取舍。由于需要标注大量的训练语料，采用人工的方法费时费力，于是采用主动学习的方法实现语料标注，我实现的步骤如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;先对语料实现人工标注一部分&lt;/li&gt;
&lt;li&gt;使用机器学习训练模型如SVM、LR对已经标注的语料训练，把为标注的语料作为测试集&lt;/li&gt;
&lt;li&gt;为测试机样本产生标签及置信度（即标签的准确性的概率值）&lt;/li&gt;
&lt;li&gt;通过观察为置信度设定一个阈值，当样本中的每个分词都满足这个阈值时，我们把这个自动标注好的测试样本加入到训练集中，在测试样本中取出这个样本&lt;/li&gt;
&lt;li&gt;重复2-4步，直到剩余的测试样本中没有完全满足阈值的&lt;/li&gt;
&lt;li&gt;&lt;p&gt;输出剩余的测试样本&lt;/p&gt;
&lt;p&gt; 刚开始我觉得这种方法非常好，经过测试，大概20次迭代之后大概4/5的样本已经标注好了&lt;br&gt;经过导师指导发现这种方法并不可靠，因为你新添加的训练集也是之前训练集产生的，反复迭代只会过拟合。我们应该设定一个比较低的阈值，找到测试集中非常不确定的测试样本（所有这些测试样本的置信度很低），通常来说这些样本是最有“价值”的样本，我们对这一小部分采用人工标注，并放入到训练集中，反复几次。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;   目前正在做句子主干提取方面的工作，主要方法是构建二分类器，提取句子分词之后每个词的特征来决定分词的取舍。由于需要标注大量的训练语料，采用人工的方法费时费力，于是采用主动学习的方法实现语料标注，我实现的步骤如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;先对语料实现人工标注一部分&lt;/
    
    </summary>
    
      <category term="句子主干提取" scheme="http://yoursite.com/categories/%E5%8F%A5%E5%AD%90%E4%B8%BB%E5%B9%B2%E6%8F%90%E5%8F%96/"/>
    
    
      <category term="逻辑回归" scheme="http://yoursite.com/tags/%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/"/>
    
      <category term="主动学习" scheme="http://yoursite.com/tags/%E4%B8%BB%E5%8A%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Pagerank算法的具体实现</title>
    <link href="http://yoursite.com/2016/06/19/pagerank%E7%AE%97%E6%B3%95%E7%9A%84%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0/"/>
    <id>http://yoursite.com/2016/06/19/pagerank算法的具体实现/</id>
    <published>2016-06-18T16:00:00.000Z</published>
    <updated>2016-07-08T07:02:10.000Z</updated>
    
    <content type="html">&lt;p&gt;PageRank对网页排名的算法，曾是Google发家致富的法宝。以前虽然有实验过，但理解还是不透彻，这几天又看了一下，这里总结一下PageRank算法的基本原理。&lt;/p&gt;
&lt;h3 id=&quot;1、什么是pagerank&quot;&gt;&lt;a href=&quot;#1、什么是pagerank&quot; class=&quot;headerlink&quot; title=&quot;1、什么是pagerank&quot;&gt;&lt;/a&gt;1、什么是pagerank&lt;/h3&gt;&lt;p&gt;PageRank的Page可是认为是网页，表示网页排名，也可以认为是Larry Page(google 产品经理)，因为他是这个算法的发明者之一，还是google CEO（^_^）。PageRank算法计算每一个网页的PageRank值，然后根据这个值的大小对网页的重要性进行排序。它的思想是模拟一个悠闲的上网者，上网者首先随机选择一个网页打开，然后在这个网页上呆了几分钟后，跳转到该网页所指向的链接，这样无所事事、漫无目的地在网页上跳来跳去，PageRank就是估计这个悠闲的上网者分布在各个网页上的概率。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;2、最简单pagerank模型&quot;&gt;&lt;a href=&quot;#2、最简单pagerank模型&quot; class=&quot;headerlink&quot; title=&quot;2、最简单pagerank模型&quot;&gt;&lt;/a&gt;2、最简单pagerank模型&lt;/h3&gt;&lt;p&gt;互联网中的网页可以看出是一个有向图，其中网页是结点，如果网页A有链接到网页B，则存在一条有向边A-&amp;gt;B，下面是一个简单的示例：&lt;br&gt;&lt;img src=&quot;http://jbcdn2.b0.upaiyun.com/2014/06/ca4f4c96cd2294c797ddf585c4188074.jpg&quot; alt=&quot;pagerank示例&quot;&gt;&lt;br&gt;这个例子中只有四个网页，如果当前在A网页，那么悠闲的上网者将会各以1/3的概率跳转到B、C、D，这里的3表示A有3条出链，如果一个网页有k条出链，那么跳转任意一个出链上的概率是1/k，同理D到B、C的概率各为1/2，而B到C的概率为0。一般用转移矩阵表示上网者的跳转概率，如果用n表示网页的数目，则转移矩阵M是一个n*n的方阵；如果网页j有k个出链，那么对每一个出链指向的网页i，有M[i][j]=1/k，而其他网页的M[i][j]=0；上面示例图对应的转移矩阵如下：&lt;br&gt;&lt;img src=&quot;http://jbcdn2.b0.upaiyun.com/2014/06/4162fcd6ae797038923715cca812e3b9.jpg&quot; alt=&quot;pagerank示例&quot;&gt;&lt;br&gt;初试时，假设上网者在每一个网页的概率都是相等的，即1/n，于是初试的概率分布就是一个所有值都为1/n的n维列向量V0，用V0去右乘转移矩阵M，就得到了第一步之后上网者的概率分布向量MV0,（nXn）*(nX1)依然得到一个nX1的矩阵。下面是V1的计算过程：&lt;br&gt;&lt;img src=&quot;http://jbcdn2.b0.upaiyun.com/2014/06/4be2f7275f8b1880bbf99e08240fec7f.jpg&quot; alt=&quot;pagerank示例&quot;&gt;&lt;br&gt;注意矩阵M中M[i][j]不为0表示用一个链接从j指向i，M的第一行乘以V0，表示累加所有网页到网页A的概率即得到9/24。得到了V1后，再用V1去右乘M得到V2，一直下去，最终V会收敛，即Vn=MV(n-1)，上面的图示例，不断的迭代，最终V=[3/9,2/9,2/9,2/9]’：&lt;br&gt;&lt;img src=&quot;http://jbcdn2.b0.upaiyun.com/2014/06/2e906d4e9404a5aadf2938f001ad0ea7.jpg&quot; alt=&quot;pagerank示例&quot;&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;PageRank对网页排名的算法，曾是Google发家致富的法宝。以前虽然有实验过，但理解还是不透彻，这几天又看了一下，这里总结一下PageRank算法的基本原理。&lt;/p&gt;
&lt;h3 id=&quot;1、什么是pagerank&quot;&gt;&lt;a href=&quot;#1、什么是pagerank&quot; class=&quot;headerlink&quot; title=&quot;1、什么是pagerank&quot;&gt;&lt;/a&gt;1、什么是pagerank&lt;/h3&gt;&lt;p&gt;PageRank的Page可是认为是网页，表示网页排名，也可以认为是Larry Page(google 产品经理)，因为他是这个算法的发明者之一，还是google CEO（^_^）。PageRank算法计算每一个网页的PageRank值，然后根据这个值的大小对网页的重要性进行排序。它的思想是模拟一个悠闲的上网者，上网者首先随机选择一个网页打开，然后在这个网页上呆了几分钟后，跳转到该网页所指向的链接，这样无所事事、漫无目的地在网页上跳来跳去，PageRank就是估计这个悠闲的上网者分布在各个网页上的概率。&lt;br&gt;
    
    </summary>
    
      <category term="实体链接" scheme="http://yoursite.com/categories/%E5%AE%9E%E4%BD%93%E9%93%BE%E6%8E%A5/"/>
    
    
      <category term="PageRank" scheme="http://yoursite.com/tags/PageRank/"/>
    
      <category term="Graph Model" scheme="http://yoursite.com/tags/Graph-Model/"/>
    
  </entry>
  
  <entry>
    <title>单链表反转问题</title>
    <link href="http://yoursite.com/2016/06/15/%E5%8D%95%E9%93%BE%E8%A1%A8%E5%8F%8D%E8%BD%AC%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2016/06/15/单链表反转问题/</id>
    <published>2016-06-14T16:00:00.000Z</published>
    <updated>2016-07-17T09:39:00.000Z</updated>
    
    <content type="html">&lt;p&gt;题目：定义一个函数，输入一个链表的头结点，反转该链表并输出反转后链表的头结点。&lt;/p&gt;
&lt;h3 id=&quot;1、非递归方式实现&quot;&gt;&lt;a href=&quot;#1、非递归方式实现&quot; class=&quot;headerlink&quot; title=&quot;1、非递归方式实现&quot;&gt;&lt;/a&gt;1、非递归方式实现&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;//思路为将节点从前到后依次放到表头，最后最后的节点到了最前面,最前面的节点到了最后面  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;ListNode * ReverseList(ListNode *  head)  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#123;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   //如果链表为空或者链表中只有一个元素  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   if(head==NULL || head-&amp;gt;m_pNext==NULL)  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;       return head;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   ListNode * p=head-&amp;gt;m_pNext;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   ListNode * q=head;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   while(p!=NULL)  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   &amp;#123;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;     q-&amp;gt;m_pNext=p-&amp;gt;m_pNext;//记录下p的下一个节点  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;     p-&amp;gt;m_pNext=head;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;     head=p;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;     p=q-&amp;gt;m_pNext;//准备将p的下一个节点放到表头  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   &amp;#125;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   return head;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=&quot;330&quot; height=&quot;86&quot; src=&quot;http://music.163.com/outchain/player?type=2&amp;id=32507038&amp;auto=1&amp;height=66&quot;&gt;&lt;/iframe&gt;&lt;/p&gt;
&lt;h3 id=&quot;2、递归方式实现&quot;&gt;&lt;a href=&quot;#2、递归方式实现&quot; class=&quot;headerlink&quot; title=&quot;2、递归方式实现&quot;&gt;&lt;/a&gt;2、递归方式实现&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;ListNode * ReverseList2(ListNode * head)  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#123;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    //如果链表为空或者链表中只有一个元素  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    if(head==NULL || head-&amp;gt;m_pNext==NULL)  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        return head;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    else  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#123;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;       ListNode * newhead=ReverseList2(head-&amp;gt;m_pNext);//先反转后面的链表  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;       head-&amp;gt;m_pNext-&amp;gt;m_pNext=head;//再将当前节点设置为其然来后面节点的后续节点  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;       head-&amp;gt;m_pNext=NULL;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;       return newhead;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;3、完整的代码流程&quot;&gt;&lt;a href=&quot;#3、完整的代码流程&quot; class=&quot;headerlink&quot; title=&quot;3、完整的代码流程&quot;&gt;&lt;/a&gt;3、完整的代码流程&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;23&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;24&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;25&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;26&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;27&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;28&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;29&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;30&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;31&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;32&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;33&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;34&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;35&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;36&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;37&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;38&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;39&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;40&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;41&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;42&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;43&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;44&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;45&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;46&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;47&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;48&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;49&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;50&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;51&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;52&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;53&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;54&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;55&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;56&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;57&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;58&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;59&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;60&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;61&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;62&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;63&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;64&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;65&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;66&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;67&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;68&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;69&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;70&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;71&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;72&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;73&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;74&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;75&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;76&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;77&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;78&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;79&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;80&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;81&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;82&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;83&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;84&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;// 反转链表.cpp : 定义控制台应用程序的入口点。  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;#include &amp;quot;stdafx.h&amp;quot;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;#include  &amp;lt;iostream&amp;gt;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;using namespace std;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;//定义一个链表节点  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt; typedef struct ListNode  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#123;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    int       m_nKey;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    struct ListNode * m_pNext;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;ListNode;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;//插入一个新节点到链表中(放在链表头部)  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;void CreateList(ListNode * &amp;amp; head,int data)  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#123;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    //创建新节点  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    ListNode * p=(ListNode*)malloc(sizeof(ListNode));  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    p-&amp;gt;m_nKey=data;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    p-&amp;gt;m_pNext=NULL;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    if(head==NULL)  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#123;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        head=p;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        return;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    p-&amp;gt;m_pNext=head;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    head=p;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;void  printList(ListNode* head)  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#123;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   ListNode * p=head;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   while(p!=NULL)  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   &amp;#123;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      cout&amp;lt;&amp;lt;p-&amp;gt;m_nKey&amp;lt;&amp;lt;&amp;quot; &amp;quot;;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      p=p-&amp;gt;m_pNext;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   &amp;#125;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   cout&amp;lt;&amp;lt;endl;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;//思路为将节点从前到后依次放到表头，最后最后的节点到了最前面,最前面的节点到了最后面  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;ListNode * ReverseList(ListNode *  head)  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#123;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   //如果链表为空或者链表中只有一个元素  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   if(head==NULL || head-&amp;gt;m_pNext==NULL)  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;       return head;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   ListNode * p=head-&amp;gt;m_pNext;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   ListNode * q=head;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   while(p!=NULL)  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   &amp;#123;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;     q-&amp;gt;m_pNext=p-&amp;gt;m_pNext;//记录下p的下一个节点  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;     p-&amp;gt;m_pNext=head;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;     head=p;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;     p=q-&amp;gt;m_pNext;//准备将p的下一个节点放到表头  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   &amp;#125;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   return head;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;//递归方式  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;ListNode * ReverseList2(ListNode * head)  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#123;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    //如果链表为空或者链表中只有一个元素  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    if(head==NULL || head-&amp;gt;m_pNext==NULL)  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        return head;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    else  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#123;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;       ListNode * newhead=ReverseList2(head-&amp;gt;m_pNext);//先反转后面的链表  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;       head-&amp;gt;m_pNext-&amp;gt;m_pNext=head;//再将当前节点设置为其然来后面节点的后续节点  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;       head-&amp;gt;m_pNext=NULL;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;       return newhead;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;int _tmain(int argc, _TCHAR* argv[])  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#123;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    ListNode * Head=NULL;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    for(int i=0;i&amp;lt;10;i++)  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      CreateList(Head,i);  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    printList(Head);  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    Head=ReverseList(Head);  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    printList(Head);  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    system(&amp;quot;PAUSE&amp;quot;);  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    return 0;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;题目：定义一个函数，输入一个链表的头结点，反转该链表并输出反转后链表的头结点。&lt;/p&gt;
&lt;h3 id=&quot;1、非递归方式实现&quot;&gt;&lt;a href=&quot;#1、非递归方式实现&quot; class=&quot;headerlink&quot; title=&quot;1、非递归方式实现&quot;&gt;&lt;/a&gt;1、非递归方式实现&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;//思路为将节点从前到后依次放到表头，最后最后的节点到了最前面,最前面的节点到了最后面  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;ListNode * ReverseList(ListNode *  head)  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#123;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   //如果链表为空或者链表中只有一个元素  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   if(head==NULL || head-&amp;gt;m_pNext==NULL)  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;       return head;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   ListNode * p=head-&amp;gt;m_pNext;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   ListNode * q=head;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   while(p!=NULL)  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   &amp;#123;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;     q-&amp;gt;m_pNext=p-&amp;gt;m_pNext;//记录下p的下一个节点  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;     p-&amp;gt;m_pNext=head;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;     head=p;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;     p=q-&amp;gt;m_pNext;//准备将p的下一个节点放到表头  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   &amp;#125;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   return head;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
